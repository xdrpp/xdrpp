<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xdrpp: xdr Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xdrpp
   </div>
   <div id="projectbrief">RFC4506 XDR compiler and message library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">xdr Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Most of the xdrpp library is encapsulated in the xdr namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1accepted__reply.html">accepted_reply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1archive__adapter.html">archive_adapter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is used to apply an archive to a field.  <a href="structxdr_1_1archive__adapter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><b>archive_adapter&lt; detail::Printer &gt;</b></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1arpc__server.html">arpc_server</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1arpc__service.html">arpc_service</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1asynchronous__client__base.html">asynchronous_client_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1call__args.html">call_args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1call__body.html">call_body</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1call__result.html">call_result</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <code>unique_ptr</code> to a call result, or NULL if the call failed (in which case <code>message</code> returns an error message).  <a href="structxdr_1_1call__result.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1call__result_3_01void_01_4.html">call_result&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1delete__addrinfo.html">delete_addrinfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A deleter to use <code>std::unique_ptr</code> with <code>addrinfo</code> structures (which must be freed recursively).  <a href="structxdr_1_1delete__addrinfo.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__archiver__t.html">field_archiver_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__assigner__t.html">field_assigner_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__constructor__t.html">field_constructor_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__destructor__t.html">field_destructor_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__ptr.html">field_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type-level representation of a pointer-to-member value.  <a href="structxdr_1_1field__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1field__size__t.html">field_size_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1generator__t.html">generator_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1generic__rpc__tcp__listener.html">generic_rpc_tcp_listener</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1indices.html">indices</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder type used to contain a parameter pack of tuple indices, so as to unpack a tuple in function call arguments.  <a href="structxdr_1_1indices.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1_ini_group.html">IniGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set of callbacks to run when parsing properties within a particular group.  <a href="structxdr_1_1_ini_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1_ini_line.html">IniLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Contents of a specific property.  <a href="classxdr_1_1_ini_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1mapping.html">mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1marshal__base.html">marshal_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common utility types and functions for all the marshaling classes.  <a href="structxdr_1_1marshal__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1marshal__noswap.html">marshal_noswap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric marshaling mixin that does not byteswap any numeric values (which will produce RFC4506 output on a big-endian machine).  <a href="structxdr_1_1marshal__noswap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1marshal__swap.html">marshal_swap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numeric marshaling mixin that byteswaps all numeric values (thus producing RFC4506 output on a little-endian machine).  <a href="structxdr_1_1marshal__swap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1message__t.html">message_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message buffer, with room at beginning for 4-byte length.  <a href="classxdr_1_1message__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1msg__sock.html">msg_sock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send and receive a series of delimited messages on a stream socket.  <a href="classxdr_1_1msg__sock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1netbuf.html">netbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1opaque__array.html">opaque_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XDR <code>opaque</code> is represented as std::uint8_t;.  <a href="structxdr_1_1opaque__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1opaque__auth.html">opaque_auth</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1_p_m_a_p___v_e_r_s.html">PMAP_VERS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1pmaplist__entry.html">pmaplist_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1pointer.html">pointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional data (represented with pointer notation in XDR source).  <a href="structxdr_1_1pointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1pollset.html">pollset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure to poll for a set of file descriptors and timeouts.  <a href="classxdr_1_1pollset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1pollset__plus.html">pollset_plus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds support for signal handlers, asynchonous events, and callbacks injected from other threads to the basic functionality in <code>pollset_light</code>.  <a href="classxdr_1_1pollset__plus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rejected__reply.html">rejected_reply</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1reply__body.html">reply_body</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1reply__cb.html">reply_cb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1reply__cb_3_01void_01_4.html">reply_cb&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rp____list.html">rp__list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpc__call__stat.html">rpc_call_stat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure encoding all the various reasons a server can decline to process an RPC call it received.  <a href="structxdr_1_1rpc__call__stat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpc__msg.html">rpc_msg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1rpc__server__base.html">rpc_server_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1rpc__sock.html">rpc_sock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A wrapper around <a class="el" href="classxdr_1_1msg__sock.html" title="Send and receive a series of delimited messages on a stream socket. ">xdr::msg_sock</a> that separates calls from replies.  <a href="classxdr_1_1rpc__sock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpc__sock__reply__t.html">rpc_sock_reply_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor wrapper around <code>rpc_sock::send_reply</code>.  <a href="structxdr_1_1rpc__sock__reply__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpc__success__hdr.html">rpc_success_hdr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure that gets marshalled as an RPC success header.  <a href="structxdr_1_1rpc__success__hdr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1rpc__tcp__listener__common.html">rpc_tcp_listener_common</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Listens for connections on a TCP socket (optionally registering the socket with <code>rpcbind</code>), and then serves one or more program/version interfaces to accepted connections.  <a href="classxdr_1_1rpc__tcp__listener__common.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcb.html">rpcb</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcb__entry.html">rpcb_entry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcb__entry__list.html">rpcb_entry_list</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcb__rmtcallargs.html">rpcb_rmtcallargs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcb__rmtcallres.html">rpcb_rmtcallres</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcb__stat.html">rpcb_stat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcbs__addrlist.html">rpcbs_addrlist</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1rpcbs__rmtcalllist.html">rpcbs_rmtcalllist</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1_r_p_c_b_v_e_r_s.html">RPCBVERS</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1_r_p_c_b_v_e_r_s4.html">RPCBVERS4</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1service__base.html">service_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1session__allocator.html">session_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trivial session allocator that just calls new and delete.  <a href="structxdr_1_1session__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1session__allocator_3_01void_01_4.html">session_allocator&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1sock__t.html">sock_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract away the type of a socket (for windows).  <a href="structxdr_1_1sock__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1srpc__server.html">srpc_server</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach RPC services to a single, connected stream socket.  <a href="classxdr_1_1srpc__server.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1srpc__service.html">srpc_service</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1synchronous__client__base.html">synchronous_client_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronous file descriptor demultiplexer.  <a href="classxdr_1_1synchronous__client__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1transparent__ptr.html">transparent_ptr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer, but that gets marshalled as the underlying object and can convert to the underlying type.  <a href="structxdr_1_1transparent__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Self-closing socket.  <a href="classxdr_1_1unique__sock.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xarray.html">xarray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">XDR arrays are implemented using std::array as a supertype.  <a href="structxdr_1_1xarray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__bad__discriminant.html">xdr_bad_discriminant</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to set invalid value for a union discriminant.  <a href="structxdr_1_1xdr__bad__discriminant.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__bad__message__size.html">xdr_bad_message_size</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Message not multiple of 4 bytes, or cannot fully be parsed.  <a href="structxdr_1_1xdr__bad__message__size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__call__error.html">xdr_call_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the exception raised in an RPC client when it reaches the server and transmits a call, with no connection or communication errors, but the server replies with an RPC-level message header refusing to execute the call.  <a href="structxdr_1_1xdr__call__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__fp__base.html">xdr_fp_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default traits for use as supertype of specializations of <code><a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr_traits</a></code> for floating-point types.  <a href="structxdr_1_1xdr__fp__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__generic__get.html">xdr_generic_get</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive type for unmarshaling from a buffer.  <a href="structxdr_1_1xdr__generic__get.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__generic__put.html">xdr_generic_put</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive type for marshaling to a buffer.  <a href="structxdr_1_1xdr__generic__put.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__integral__base.html">xdr_integral_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default traits for use as supertype of specializations of <code><a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr_traits</a></code> for integral types.  <a href="structxdr_1_1xdr__integral__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__invariant__failed.html">xdr_invariant_failed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception for use by <code>xdr::xdr_validate</code>.  <a href="structxdr_1_1xdr__invariant__failed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__overflow.html">xdr_overflow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to exceed the bounds of a variable-length array or string.  <a href="structxdr_1_1xdr__overflow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__runtime__error.html">xdr_runtime_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic class of XDR unmarshaling errors.  <a href="structxdr_1_1xdr__runtime__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__should__be__zero.html">xdr_should_be_zero</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Padding bytes that should have contained zero don't.  <a href="structxdr_1_1xdr__should__be__zero.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__struct__base.html">xdr_struct_base</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__struct__base_3_01_f_p_00_01_rest_8_8_8_01_4.html">xdr_struct_base&lt; FP, Rest... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__struct__base_3_4.html">xdr_struct_base&lt;&gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Supertype to construct XDR traits of structure objects, used in output of the <code>xdrc</code> compiler.  <a href="structxdr_1_1xdr__struct__base_3_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__system__error.html">xdr_system_error</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception represents a system error encountered while attempting to send RPC messages over a socket.  <a href="structxdr_1_1xdr__system__error.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metadata for all marshalable XDR types.  <a href="structxdr_1_1xdr__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01bool_01_4.html">xdr_traits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01double_01_4.html">xdr_traits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01float_01_4.html">xdr_traits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01opaque__array_3_01_n_01_4_01_4.html">xdr_traits&lt; opaque_array&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01pointer_3_01_t_01_4_01_4.html">xdr_traits&lt; pointer&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01rpc__success__hdr_01_4.html">xdr_traits&lt; rpc_success_hdr &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1int32__t_01_4.html">xdr_traits&lt; std::int32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1int64__t_01_4.html">xdr_traits&lt; std::int64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1tuple_3_01_t_8_8_8_01_4_01_4.html">xdr_traits&lt; std::tuple&lt; T... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1uint32__t_01_4.html">xdr_traits&lt; std::uint32_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01std_1_1uint64__t_01_4.html">xdr_traits&lt; std::uint64_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01transparent__ptr_3_01_t_01_4_01_4.html">xdr_traits&lt; transparent_ptr&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xarray_3_01_t_00_01_n_01_4_01_4.html">xdr_traits&lt; xarray&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xstring_3_01_n_01_4_01_4.html">xdr_traits&lt; xstring&lt; N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xvector_3_01std_1_1uint8__t_00_01_n_01_4_01_4.html">xdr_traits&lt; xvector&lt; std::uint8_t, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_01xvector_3_01_t_00_01_n_01_4_01_4.html">xdr_traits&lt; xvector&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1accept__stat_01_4.html">xdr_traits&lt;::xdr::accept_stat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1accepted__reply_01_4.html">xdr_traits&lt;::xdr::accepted_reply &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1accepted__reply_1_1__reply__data__t_01_4.html">xdr_traits&lt;::xdr::accepted_reply::_reply_data_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1accepted__reply_1_1__reply__data__t_1_1__mismatch__info__t_01_4.html">xdr_traits&lt;::xdr::accepted_reply::_reply_data_t::_mismatch_info_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1auth__flavor_01_4.html">xdr_traits&lt;::xdr::auth_flavor &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1auth__stat_01_4.html">xdr_traits&lt;::xdr::auth_stat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1call__args_01_4.html">xdr_traits&lt;::xdr::call_args &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1call__body_01_4.html">xdr_traits&lt;::xdr::call_body &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1call__result_01_4.html">xdr_traits&lt;::xdr::call_result &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1mapping_01_4.html">xdr_traits&lt;::xdr::mapping &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1msg__type_01_4.html">xdr_traits&lt;::xdr::msg_type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1netbuf_01_4.html">xdr_traits&lt;::xdr::netbuf &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1opaque__auth_01_4.html">xdr_traits&lt;::xdr::opaque_auth &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1pmaplist__entry_01_4.html">xdr_traits&lt;::xdr::pmaplist_entry &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1reject__stat_01_4.html">xdr_traits&lt;::xdr::reject_stat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rejected__reply_01_4.html">xdr_traits&lt;::xdr::rejected_reply &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rejected__reply_1_1__mismatch__info__t_01_4.html">xdr_traits&lt;::xdr::rejected_reply::_mismatch_info_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1reply__body_01_4.html">xdr_traits&lt;::xdr::reply_body &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1reply__stat_01_4.html">xdr_traits&lt;::xdr::reply_stat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rp____list_01_4.html">xdr_traits&lt;::xdr::rp__list &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpc__msg_01_4.html">xdr_traits&lt;::xdr::rpc_msg &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpc__msg_1_1__body__t_01_4.html">xdr_traits&lt;::xdr::rpc_msg::_body_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcb_01_4.html">xdr_traits&lt;::xdr::rpcb &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcb__entry_01_4.html">xdr_traits&lt;::xdr::rpcb_entry &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcb__entry__list_01_4.html">xdr_traits&lt;::xdr::rpcb_entry_list &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcb__rmtcallargs_01_4.html">xdr_traits&lt;::xdr::rpcb_rmtcallargs &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcb__rmtcallres_01_4.html">xdr_traits&lt;::xdr::rpcb_rmtcallres &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcb__stat_01_4.html">xdr_traits&lt;::xdr::rpcb_stat &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcbs__addrlist_01_4.html">xdr_traits&lt;::xdr::rpcbs_addrlist &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits_3_1_1xdr_1_1rpcbs__rmtcalllist_01_4.html">xdr_traits&lt;::xdr::rpcbs_rmtcalllist &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__traits__base.html">xdr_traits_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr_traits</a> values for actual XDR types, used as a supertype for most <a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr::xdr_traits</a> specializations.  <a href="structxdr_1_1xdr__traits__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xdr__wrong__union.html">xdr_wrong_union</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempt to access wrong field of a union.  <a href="structxdr_1_1xdr__wrong__union.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xstring.html">xstring</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A string with a maximum length (returned by <a class="el" href="structxdr_1_1xstring.html#a432cab05af13b6b1d215f2b1a48749b9" title="Return the maximum size allowed by the type. ">xstring::max_size()</a>).  <a href="structxdr_1_1xstring.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structxdr_1_1xvector.html">xvector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector with a maximum size (returned by <a class="el" href="structxdr_1_1xvector.html#a138117a326165c047497a7fca76b4c74" title="Return the maximum size allowed by the type. ">xvector::max_size()</a>).  <a href="structxdr_1_1xvector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aff1329c90251167fd606a84558025185"><td class="memTemplParams" colspan="2"><a id="aff1329c90251167fd606a84558025185"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aff1329c90251167fd606a84558025185"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arpc_client</b> = typename T::template _xdr_client&lt; <a class="el" href="classxdr_1_1asynchronous__client__base.html">asynchronous_client_base</a> &gt;</td></tr>
<tr class="separator:aff1329c90251167fd606a84558025185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e6a611df76a7c1a97880bb575c7b23c"><td class="memTemplParams" colspan="2"><a id="a3e6a611df76a7c1a97880bb575c7b23c"></a>
template&lt;typename Session  = void, typename SessionAllocator  = session_allocator&lt;Session&gt;&gt; </td></tr>
<tr class="memitem:a3e6a611df76a7c1a97880bb575c7b23c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>arpc_tcp_listener</b> = <a class="el" href="classxdr_1_1generic__rpc__tcp__listener.html">generic_rpc_tcp_listener</a>&lt; <a class="el" href="classxdr_1_1arpc__service.html">arpc_service</a>, Session, SessionAllocator &gt;</td></tr>
<tr class="separator:a3e6a611df76a7c1a97880bb575c7b23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5c7f8b19b701745ea2823cfd02df2c"><td class="memItemLeft" align="right" valign="top"><a id="a9e5c7f8b19b701745ea2823cfd02df2c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a9e5c7f8b19b701745ea2823cfd02df2c">IniActions</a> = std::unordered_map&lt; string, <a class="el" href="structxdr_1_1_ini_group.html">IniGroup</a> &gt;</td></tr>
<tr class="memdesc:a9e5c7f8b19b701745ea2823cfd02df2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the actions to execute on various properties in the ini file. <br /></td></tr>
<tr class="separator:a9e5c7f8b19b701745ea2823cfd02df2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada33de797c38967d4949ee0a6bbaa360"><td class="memItemLeft" align="right" valign="top"><a id="ada33de797c38967d4949ee0a6bbaa360"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#ada33de797c38967d4949ee0a6bbaa360">xdr_put</a> = <a class="el" href="structxdr_1_1xdr__generic__put.html">xdr_generic_put</a>&lt; <a class="el" href="structxdr_1_1marshal__swap.html">marshal_swap</a> &gt;</td></tr>
<tr class="memdesc:ada33de797c38967d4949ee0a6bbaa360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive for marshaling in RFC4506 big-endian order. <br /></td></tr>
<tr class="separator:ada33de797c38967d4949ee0a6bbaa360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ddb7d22818bba6cfa7371662d09d95"><td class="memItemLeft" align="right" valign="top"><a id="a53ddb7d22818bba6cfa7371662d09d95"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a53ddb7d22818bba6cfa7371662d09d95">xdr_get</a> = <a class="el" href="structxdr_1_1xdr__generic__get.html">xdr_generic_get</a>&lt; <a class="el" href="structxdr_1_1marshal__swap.html">marshal_swap</a> &gt;</td></tr>
<tr class="memdesc:a53ddb7d22818bba6cfa7371662d09d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Archive for unmarshaling in RFC4506 big-endian order. <br /></td></tr>
<tr class="separator:a53ddb7d22818bba6cfa7371662d09d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a17ef5b1545a379b15ebed2b11f580e"><td class="memItemLeft" align="right" valign="top"><a id="a9a17ef5b1545a379b15ebed2b11f580e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>msg_ptr</b> = std::unique_ptr&lt; <a class="el" href="classxdr_1_1message__t.html">message_t</a> &gt;</td></tr>
<tr class="separator:a9a17ef5b1545a379b15ebed2b11f580e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206241907be2e97973da4d790b6ce982"><td class="memItemLeft" align="right" valign="top"><a id="a206241907be2e97973da4d790b6ce982"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcblist_ptr</b> = <a class="el" href="structxdr_1_1pointer.html">xdr::pointer</a>&lt; <a class="el" href="structxdr_1_1rp____list.html">rp__list</a> &gt;</td></tr>
<tr class="separator:a206241907be2e97973da4d790b6ce982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62e5e11747b6615d029418392c3946c"><td class="memItemLeft" align="right" valign="top"><a id="af62e5e11747b6615d029418392c3946c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcb_entry_list_ptr</b> = <a class="el" href="structxdr_1_1pointer.html">xdr::pointer</a>&lt; <a class="el" href="structxdr_1_1rpcb__entry__list.html">rpcb_entry_list</a> &gt;</td></tr>
<tr class="separator:af62e5e11747b6615d029418392c3946c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e134a63b8b95c34f7c4b0b4c4345950"><td class="memItemLeft" align="right" valign="top"><a id="a8e134a63b8b95c34f7c4b0b4c4345950"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcbs_proc</b> = <a class="el" href="structxdr_1_1xarray.html">xdr::xarray</a>&lt; std::int32_t, RPCBSTAT_HIGHPROC &gt;</td></tr>
<tr class="separator:a8e134a63b8b95c34f7c4b0b4c4345950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d60df46c0f4d425e4c6133e38e71e40"><td class="memItemLeft" align="right" valign="top"><a id="a1d60df46c0f4d425e4c6133e38e71e40"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcbs_addrlist_ptr</b> = <a class="el" href="structxdr_1_1pointer.html">xdr::pointer</a>&lt; <a class="el" href="structxdr_1_1rpcbs__addrlist.html">rpcbs_addrlist</a> &gt;</td></tr>
<tr class="separator:a1d60df46c0f4d425e4c6133e38e71e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27bead910940d5668d9aa5f25cd45a3"><td class="memItemLeft" align="right" valign="top"><a id="aa27bead910940d5668d9aa5f25cd45a3"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcbs_rmtcalllist_ptr</b> = <a class="el" href="structxdr_1_1pointer.html">xdr::pointer</a>&lt; <a class="el" href="structxdr_1_1rpcbs__rmtcalllist.html">rpcbs_rmtcalllist</a> &gt;</td></tr>
<tr class="separator:aa27bead910940d5668d9aa5f25cd45a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01a36c9014422d94c05348656919aed"><td class="memItemLeft" align="right" valign="top"><a id="af01a36c9014422d94c05348656919aed"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcb_stat_byvers</b> = <a class="el" href="structxdr_1_1xarray.html">xdr::xarray</a>&lt; <a class="el" href="structxdr_1_1rpcb__stat.html">rpcb_stat</a>, RPCBVERS_STAT &gt;</td></tr>
<tr class="separator:af01a36c9014422d94c05348656919aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6231dad6434d7964e083c1b72d248d"><td class="memItemLeft" align="right" valign="top"><a id="aca6231dad6434d7964e083c1b72d248d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>rpcb_string</b> = <a class="el" href="structxdr_1_1xstring.html">xdr::xstring</a>&lt;&gt;</td></tr>
<tr class="separator:aca6231dad6434d7964e083c1b72d248d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab67f804a1daa0bb2d30ee268b2fb359"><td class="memItemLeft" align="right" valign="top"><a id="aab67f804a1daa0bb2d30ee268b2fb359"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pmaplist</b> = <a class="el" href="structxdr_1_1pointer.html">xdr::pointer</a>&lt; <a class="el" href="structxdr_1_1pmaplist__entry.html">pmaplist_entry</a> &gt;</td></tr>
<tr class="separator:aab67f804a1daa0bb2d30ee268b2fb359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7bd9c2f3e417b290472c3b1ef28884"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7e7bd9c2f3e417b290472c3b1ef28884"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a7e7bd9c2f3e417b290472c3b1ef28884">wrap_transparent_ptr</a> = typename detail::wrap_transparent_ptr_helper&lt; T &gt;::type</td></tr>
<tr class="memdesc:a7e7bd9c2f3e417b290472c3b1ef28884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap <a class="el" href="structxdr_1_1transparent__ptr.html" title="A pointer, but that gets marshalled as the underlying object and can convert to the underlying type...">xdr::transparent_ptr</a> around each type in a tuple to generate a new tuple type.  <a href="#a7e7bd9c2f3e417b290472c3b1ef28884">More...</a><br /></td></tr>
<tr class="separator:a7e7bd9c2f3e417b290472c3b1ef28884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b183e470bc78ebaa3d03b86dda2aa9"><td class="memItemLeft" align="right" valign="top"><a id="a68b183e470bc78ebaa3d03b86dda2aa9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a68b183e470bc78ebaa3d03b86dda2aa9">unique_addrinfo</a> = std::unique_ptr&lt; addrinfo, <a class="el" href="structxdr_1_1delete__addrinfo.html">delete_addrinfo</a> &gt;</td></tr>
<tr class="memdesc:a68b183e470bc78ebaa3d03b86dda2aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatically garbage-collected addrinfo pointer. <br /></td></tr>
<tr class="separator:a68b183e470bc78ebaa3d03b86dda2aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665952498b5c2be139ae076f5f9cd724"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a665952498b5c2be139ae076f5f9cd724"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a665952498b5c2be139ae076f5f9cd724">srpc_client</a> = typename T::template _xdr_client&lt; <a class="el" href="classxdr_1_1synchronous__client__base.html">synchronous_client_base</a> &gt;</td></tr>
<tr class="memdesc:a665952498b5c2be139ae076f5f9cd724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an RPC client from an interface type and connected stream socket.  <a href="#a665952498b5c2be139ae076f5f9cd724">More...</a><br /></td></tr>
<tr class="separator:a665952498b5c2be139ae076f5f9cd724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a52acb1991ef4d3ff7250cff2cd0e1e"><td class="memTemplParams" colspan="2"><a id="a5a52acb1991ef4d3ff7250cff2cd0e1e"></a>
template&lt;typename Session  = void, typename SessionAllocator  = session_allocator&lt;Session&gt;&gt; </td></tr>
<tr class="memitem:a5a52acb1991ef4d3ff7250cff2cd0e1e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>srpc_tcp_listener</b> = <a class="el" href="classxdr_1_1generic__rpc__tcp__listener.html">generic_rpc_tcp_listener</a>&lt; <a class="el" href="classxdr_1_1srpc__service.html">srpc_service</a>, Session, SessionAllocator &gt;</td></tr>
<tr class="separator:a5a52acb1991ef4d3ff7250cff2cd0e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08a12c21ae987530a9aadfdec31e593"><td class="memTemplParams" colspan="2"><a id="aa08a12c21ae987530a9aadfdec31e593"></a>
template&lt;uint32_t N = XDR_MAX_LEN&gt; </td></tr>
<tr class="memitem:aa08a12c21ae987530a9aadfdec31e593"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aa08a12c21ae987530a9aadfdec31e593">opaque_vec</a> = <a class="el" href="structxdr_1_1xvector.html">xvector</a>&lt; std::uint8_t, N &gt;</td></tr>
<tr class="memdesc:aa08a12c21ae987530a9aadfdec31e593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variable-length opaque data is just a vector of std::uint8_t. <br /></td></tr>
<tr class="separator:aa08a12c21ae987530a9aadfdec31e593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c6ab2a25cb7603d964833140dbfcdb"><td class="memTemplParams" colspan="2"><a id="a20c6ab2a25cb7603d964833140dbfcdb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20c6ab2a25cb7603d964833140dbfcdb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a20c6ab2a25cb7603d964833140dbfcdb">all_indices_of</a> = typename detail::all_indices&lt; std::tuple_size&lt; typename std::remove_reference&lt; T &gt;::type &gt;::value &gt;</td></tr>
<tr class="memdesc:a20c6ab2a25cb7603d964833140dbfcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A type representing all the indices of a particuar tuple. <br /></td></tr>
<tr class="separator:a20c6ab2a25cb7603d964833140dbfcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8434488dfa0bf61c3ba2714eb1e6ffba"><td class="memItemLeft" align="right" valign="top"><a id="a8434488dfa0bf61c3ba2714eb1e6ffba"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a8434488dfa0bf61c3ba2714eb1e6ffba">xdr_void</a> = std::tuple&lt;&gt;</td></tr>
<tr class="memdesc:a8434488dfa0bf61c3ba2714eb1e6ffba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placehoder type representing void values marshaled as 0 bytes. <br /></td></tr>
<tr class="separator:a8434488dfa0bf61c3ba2714eb1e6ffba"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a6a2f5126b13bcfbedf87a9fc459cd715"><td class="memItemLeft" align="right" valign="top"><a id="a6a2f5126b13bcfbedf87a9fc459cd715"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>auth_flavor</b> : std::int32_t { <br />
&#160;&#160;<b>AUTH_NONE</b> = 0, 
<b>AUTH_SYS</b> = 1, 
<b>AUTH_SHORT</b> = 2, 
<b>AUTH_DH</b> = 3, 
<br />
&#160;&#160;<b>RPCSEC_GSS</b> = 6
<br />
 }</td></tr>
<tr class="separator:a6a2f5126b13bcfbedf87a9fc459cd715"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b3d85c40dc8734dfc85156cb2dc2fa"><td class="memItemLeft" align="right" valign="top"><a id="a20b3d85c40dc8734dfc85156cb2dc2fa"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>msg_type</b> : std::int32_t { <b>CALL</b> = 0, 
<b>REPLY</b> = 1
 }</td></tr>
<tr class="separator:a20b3d85c40dc8734dfc85156cb2dc2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a927413c32480e93b7bbf87eaead15"><td class="memItemLeft" align="right" valign="top"><a id="a15a927413c32480e93b7bbf87eaead15"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>reply_stat</b> : std::int32_t { <b>MSG_ACCEPTED</b> = 0, 
<b>MSG_DENIED</b> = 1
 }</td></tr>
<tr class="separator:a15a927413c32480e93b7bbf87eaead15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f99cba4e5d7730b0d36e8b5a887e3d"><td class="memItemLeft" align="right" valign="top"><a id="a11f99cba4e5d7730b0d36e8b5a887e3d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>accept_stat</b> : std::int32_t { <br />
&#160;&#160;<b>SUCCESS</b> = 0, 
<b>PROG_UNAVAIL</b> = 1, 
<b>PROG_MISMATCH</b> = 2, 
<b>PROC_UNAVAIL</b> = 3, 
<br />
&#160;&#160;<b>GARBAGE_ARGS</b> = 4, 
<b>SYSTEM_ERR</b> = 5
<br />
 }</td></tr>
<tr class="separator:a11f99cba4e5d7730b0d36e8b5a887e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea6613feeb448054ca4051c6c22d7a5"><td class="memItemLeft" align="right" valign="top"><a id="aeea6613feeb448054ca4051c6c22d7a5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>reject_stat</b> : std::int32_t { <b>RPC_MISMATCH</b> = 0, 
<b>AUTH_ERROR</b> = 1
 }</td></tr>
<tr class="separator:aeea6613feeb448054ca4051c6c22d7a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191695e7a895c0e6fcf2099cb4b1ad14"><td class="memItemLeft" align="right" valign="top"><a id="a191695e7a895c0e6fcf2099cb4b1ad14"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>auth_stat</b> : std::int32_t { <br />
&#160;&#160;<b>AUTH_OK</b> = 0, 
<b>AUTH_BADCRED</b> = 1, 
<b>AUTH_REJECTEDCRED</b> = 2, 
<b>AUTH_BADVERF</b> = 3, 
<br />
&#160;&#160;<b>AUTH_REJECTEDVERF</b> = 4, 
<b>AUTH_TOOWEAK</b> = 5, 
<b>AUTH_INVALIDRESP</b> = 6, 
<b>AUTH_FAILED</b> = 7, 
<br />
&#160;&#160;<b>AUTH_KERB_GENERIC</b> = 8, 
<b>AUTH_TIMEEXPIRE</b> = 9, 
<b>AUTH_TKT_FILE</b> = 10, 
<b>AUTH_DECODE</b> = 11, 
<br />
&#160;&#160;<b>AUTH_NET_ADDR</b> = 12, 
<b>RPCSEC_GSS_CREDPROBLEM</b> = 13, 
<b>RPCSEC_GSS_CTXPROBLEM</b> = 14
<br />
 }</td></tr>
<tr class="separator:a191695e7a895c0e6fcf2099cb4b1ad14"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a59284e4264367ff7e7f8a2aa4fb747b0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59284e4264367ff7e7f8a2aa4fb747b0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a59284e4264367ff7e7f8a2aa4fb747b0">xdr_clear</a> (T &amp;t)</td></tr>
<tr class="memdesc:a59284e4264367ff7e7f8a2aa4fb747b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset XDR data structure to its default contents.  <a href="#a59284e4264367ff7e7f8a2aa4fb747b0">More...</a><br /></td></tr>
<tr class="separator:a59284e4264367ff7e7f8a2aa4fb747b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a9c6ed587a0b29d56905514796244d"><td class="memItemLeft" align="right" valign="top"><a id="a98a9c6ed587a0b29d56905514796244d"></a>
Constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a98a9c6ed587a0b29d56905514796244d">swap32</a> (std::uint32_t v)</td></tr>
<tr class="memdesc:a98a9c6ed587a0b29d56905514796244d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byteswap 32-bit number. <br /></td></tr>
<tr class="separator:a98a9c6ed587a0b29d56905514796244d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c453bfc6eb0d2fd82fde4016c9a2a7"><td class="memItemLeft" align="right" valign="top"><a id="a25c453bfc6eb0d2fd82fde4016c9a2a7"></a>
Constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a25c453bfc6eb0d2fd82fde4016c9a2a7">swap64</a> (std::uint64_t v)</td></tr>
<tr class="memdesc:a25c453bfc6eb0d2fd82fde4016c9a2a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byteswap 64-bit number. <br /></td></tr>
<tr class="separator:a25c453bfc6eb0d2fd82fde4016c9a2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605445f875b34ef7516d6ebf443d66f6"><td class="memItemLeft" align="right" valign="top">Constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a605445f875b34ef7516d6ebf443d66f6">swap32le</a> (std::uint32_t v)</td></tr>
<tr class="memdesc:a605445f875b34ef7516d6ebf443d66f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byteswap 32-bit value only on little-endian machines, identity function on big-endian machines.  <a href="#a605445f875b34ef7516d6ebf443d66f6">More...</a><br /></td></tr>
<tr class="separator:a605445f875b34ef7516d6ebf443d66f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce3f3c23751bdf796d89bae603e9ef7"><td class="memItemLeft" align="right" valign="top"><a id="a3ce3f3c23751bdf796d89bae603e9ef7"></a>
Constexpr std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a3ce3f3c23751bdf796d89bae603e9ef7">swap32be</a> (std::uint32_t v)</td></tr>
<tr class="memdesc:a3ce3f3c23751bdf796d89bae603e9ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byteswap 32-bit value only on big-endian machines. <br /></td></tr>
<tr class="separator:a3ce3f3c23751bdf796d89bae603e9ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fb317655bfe551f148e44125edb9e5"><td class="memItemLeft" align="right" valign="top"><a id="a11fb317655bfe551f148e44125edb9e5"></a>
Constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a11fb317655bfe551f148e44125edb9e5">swap64le</a> (std::uint64_t v)</td></tr>
<tr class="memdesc:a11fb317655bfe551f148e44125edb9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byteswap 64-bit value only on little-endian machines. <br /></td></tr>
<tr class="separator:a11fb317655bfe551f148e44125edb9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2b70a767c5a1e4764f8ab62cb0aa9a"><td class="memItemLeft" align="right" valign="top"><a id="a6d2b70a767c5a1e4764f8ab62cb0aa9a"></a>
Constexpr std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a6d2b70a767c5a1e4764f8ab62cb0aa9a">swap64be</a> (std::uint64_t v)</td></tr>
<tr class="memdesc:a6d2b70a767c5a1e4764f8ab62cb0aa9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Byteswap 64-bit value only on big-endian machines. <br /></td></tr>
<tr class="separator:a6d2b70a767c5a1e4764f8ab62cb0aa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cae979b12b9ac90019d9e5bddfc910"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a65cae979b12b9ac90019d9e5bddfc910">rpc_errmsg</a> (accept_stat ev)</td></tr>
<tr class="memdesc:a65cae979b12b9ac90019d9e5bddfc910"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate one of the conditions in <a href="https://tools.ietf.org/html/rfc5531">RFC5531</a> for an unexecuted call into a string.  <a href="#a65cae979b12b9ac90019d9e5bddfc910">More...</a><br /></td></tr>
<tr class="separator:a65cae979b12b9ac90019d9e5bddfc910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff0799b0b3dcdbc6f9f01a2cb284609a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aff0799b0b3dcdbc6f9f01a2cb284609a">rpc_errmsg</a> (auth_stat ev)</td></tr>
<tr class="memdesc:aff0799b0b3dcdbc6f9f01a2cb284609a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translate one of the conditions in <a href="https://tools.ietf.org/html/rfc5531">RFC5531</a> for an unexecuted call into a string.  <a href="#aff0799b0b3dcdbc6f9f01a2cb284609a">More...</a><br /></td></tr>
<tr class="separator:aff0799b0b3dcdbc6f9f01a2cb284609a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84733139d5a17fd33d7baa75290b9282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a84733139d5a17fd33d7baa75290b9282">check_call_hdr</a> (const <a class="el" href="structxdr_1_1rpc__msg.html">rpc_msg</a> &amp;hdr)</td></tr>
<tr class="memdesc:a84733139d5a17fd33d7baa75290b9282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check that an RPC header precedes a result.  <a href="#a84733139d5a17fd33d7baa75290b9282">More...</a><br /></td></tr>
<tr class="separator:a84733139d5a17fd33d7baa75290b9282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c2ca4ddc6b204148c348718fda93a8"><td class="memItemLeft" align="right" valign="top"><a id="aa2c2ca4ddc6b204148c348718fda93a8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>ini_unescape</b> (string::const_iterator, string::const_iterator, string *)</td></tr>
<tr class="separator:aa2c2ca4ddc6b204148c348718fda93a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e297277f72282a6465caa62f6a790c"><td class="memItemLeft" align="right" valign="top"><a id="aa1e297277f72282a6465caa62f6a790c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_string</b> (const string &amp;s, string *sp)</td></tr>
<tr class="separator:aa1e297277f72282a6465caa62f6a790c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7bdcd08710fee1d52315eb870cfd6a"><td class="memItemLeft" align="right" valign="top"><a id="a4d7bdcd08710fee1d52315eb870cfd6a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>from_string</b> (const string &amp;s, bool *bp)</td></tr>
<tr class="separator:a4d7bdcd08710fee1d52315eb870cfd6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fa92816e33f00060e07c5f27365590"><td class="memTemplParams" colspan="2"><a id="ae2fa92816e33f00060e07c5f27365590"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:ae2fa92816e33f00060e07c5f27365590"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_base</b> (T(&amp;conv)(const string &amp;, size_t *, int), const string &amp;s, size_t *pos)</td></tr>
<tr class="separator:ae2fa92816e33f00060e07c5f27365590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da1dea0d2e89b1eaec97ebbb7fe0cf7"><td class="memTemplParams" colspan="2"><a id="a0da1dea0d2e89b1eaec97ebbb7fe0cf7"></a>
template&lt;class T &gt; </td></tr>
<tr class="memitem:a0da1dea0d2e89b1eaec97ebbb7fe0cf7"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_base</b> (T(&amp;conv)(const string &amp;, size_t *), const string &amp;s, size_t *pos)</td></tr>
<tr class="separator:a0da1dea0d2e89b1eaec97ebbb7fe0cf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2b6c9dad781c40b340516f2d3058263"><td class="memTemplParams" colspan="2"><a id="ac2b6c9dad781c40b340516f2d3058263"></a>
template&lt;typename T , typename U , typename ... Base&gt; </td></tr>
<tr class="memitem:ac2b6c9dad781c40b340516f2d3058263"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>from_string_with</b> (U(&amp;conv)(const string &amp;, size_t *, Base...), const string &amp;s, T *rp)</td></tr>
<tr class="separator:ac2b6c9dad781c40b340516f2d3058263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0792a686ac45635d0d87eaeea94626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a4c0792a686ac45635d0d87eaeea94626">ini_runparse</a> (<a class="el" href="namespacexdr.html#a9e5c7f8b19b701745ea2823cfd02df2c">IniActions</a> &amp;a, <a class="el" href="classxdr_1_1_ini_line.html">IniLine</a> &amp;st, std::istream &amp;s)</td></tr>
<tr class="memdesc:a4c0792a686ac45635d0d87eaeea94626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the ini parser.  <a href="#a4c0792a686ac45635d0d87eaeea94626">More...</a><br /></td></tr>
<tr class="separator:a4c0792a686ac45635d0d87eaeea94626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862bd95cc733394bccab8cb62b07ded1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a862bd95cc733394bccab8cb62b07ded1">ini_parse</a> (<a class="el" href="namespacexdr.html#a9e5c7f8b19b701745ea2823cfd02df2c">IniActions</a> &amp;a, string file)</td></tr>
<tr class="memdesc:a862bd95cc733394bccab8cb62b07ded1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the parser on a file.  <a href="#a862bd95cc733394bccab8cb62b07ded1">More...</a><br /></td></tr>
<tr class="separator:a862bd95cc733394bccab8cb62b07ded1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfe4987b106375586afc4dd5e95b912"><td class="memItemLeft" align="right" valign="top"><a id="adbfe4987b106375586afc4dd5e95b912"></a>
std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>xdr_argpack_size</b> ()</td></tr>
<tr class="separator:adbfe4987b106375586afc4dd5e95b912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1311bd280e8506fef5e58102dc4c6764"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a1311bd280e8506fef5e58102dc4c6764"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a1311bd280e8506fef5e58102dc4c6764">xdr_argpack_size</a> (const T &amp;t, const Args &amp;...a)</td></tr>
<tr class="memdesc:a1311bd280e8506fef5e58102dc4c6764"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sum of bytes required to marshal all of the argument values.  <a href="#a1311bd280e8506fef5e58102dc4c6764">More...</a><br /></td></tr>
<tr class="separator:a1311bd280e8506fef5e58102dc4c6764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476e2045fff8173e7549358f30950f01"><td class="memTemplParams" colspan="2"><a id="a476e2045fff8173e7549358f30950f01"></a>
template&lt;typename Archive &gt; </td></tr>
<tr class="memitem:a476e2045fff8173e7549358f30950f01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>xdr_argpack_archive</b> (Archive &amp;)</td></tr>
<tr class="separator:a476e2045fff8173e7549358f30950f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5702dbf3249c5809f840db149b0a75"><td class="memTemplParams" colspan="2"><a id="a5b5702dbf3249c5809f840db149b0a75"></a>
template&lt;typename Archive , typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a5b5702dbf3249c5809f840db149b0a75"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a5b5702dbf3249c5809f840db149b0a75">xdr_argpack_archive</a> (Archive &amp;ar, T &amp;&amp;t, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a5b5702dbf3249c5809f840db149b0a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an archive to each argument. <br /></td></tr>
<tr class="separator:a5b5702dbf3249c5809f840db149b0a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93354eb4678f9f00c8bb204d5e6c38a7"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a93354eb4678f9f00c8bb204d5e6c38a7"><td class="memTemplItemLeft" align="right" valign="top">msg_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a93354eb4678f9f00c8bb204d5e6c38a7">xdr_to_msg</a> (const Args &amp;...args)</td></tr>
<tr class="memdesc:a93354eb4678f9f00c8bb204d5e6c38a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marshal one or a series of XDR types into a newly allocated buffer referenced xdr::msg_ptr.  <a href="#a93354eb4678f9f00c8bb204d5e6c38a7">More...</a><br /></td></tr>
<tr class="separator:a93354eb4678f9f00c8bb204d5e6c38a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6623f431944ea9e0a2158310e45622"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a5a6623f431944ea9e0a2158310e45622"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacexdr.html#aa08a12c21ae987530a9aadfdec31e593">opaque_vec</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a5a6623f431944ea9e0a2158310e45622">xdr_to_opaque</a> (const Args &amp;...args)</td></tr>
<tr class="memdesc:a5a6623f431944ea9e0a2158310e45622"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marshal one or a series of XDR types into a newly allocated opaque structure for embedding in other XDR types.  <a href="#a5a6623f431944ea9e0a2158310e45622">More...</a><br /></td></tr>
<tr class="separator:a5a6623f431944ea9e0a2158310e45622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3196352f957cea3cca6ca44c2a72ef70"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a3196352f957cea3cca6ca44c2a72ef70"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a3196352f957cea3cca6ca44c2a72ef70">xdr_from_msg</a> (const msg_ptr &amp;m, Args &amp;...args)</td></tr>
<tr class="memdesc:a3196352f957cea3cca6ca44c2a72ef70"><td class="mdescLeft">&#160;</td><td class="mdescRight">This does the reverse of <a class="el" href="namespacexdr.html#a93354eb4678f9f00c8bb204d5e6c38a7" title="Marshal one or a series of XDR types into a newly allocated buffer referenced xdr::msg_ptr. ">xdr::xdr_to_msg</a>, unmarshalling one or more types from a message.  <a href="#a3196352f957cea3cca6ca44c2a72ef70">More...</a><br /></td></tr>
<tr class="separator:a3196352f957cea3cca6ca44c2a72ef70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecff6ceff74126580df8e2f130fcc37"><td class="memTemplParams" colspan="2">template&lt;typename Bytes , typename... Args&gt; </td></tr>
<tr class="memitem:a1ecff6ceff74126580df8e2f130fcc37"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a1ecff6ceff74126580df8e2f130fcc37">xdr_from_opaque</a> (const Bytes &amp;m, Args &amp;...args) -&gt; decltype(detail::bytes_to_void(m.data()))</td></tr>
<tr class="memdesc:a1ecff6ceff74126580df8e2f130fcc37"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reverse of <a class="el" href="namespacexdr.html#a5a6623f431944ea9e0a2158310e45622" title="Marshal one or a series of XDR types into a newly allocated opaque structure for embedding in other X...">xdr::xdr_to_opaque</a>.  <a href="#a1ecff6ceff74126580df8e2f130fcc37">More...</a><br /></td></tr>
<tr class="separator:a1ecff6ceff74126580df8e2f130fcc37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3cf7e21f78488fe542f8a8e5793af8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aed3cf7e21f78488fe542f8a8e5793af8">escape_string</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:aed3cf7e21f78488fe542f8a8e5793af8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use hex escapes for non-printable characters, and prefix backslashes and quotes with backslash.  <a href="#aed3cf7e21f78488fe542f8a8e5793af8">More...</a><br /></td></tr>
<tr class="separator:aed3cf7e21f78488fe542f8a8e5793af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3a3679ad9faa3a3cad48d6c5d25cb5"><td class="memItemLeft" align="right" valign="top"><a id="adc3a3679ad9faa3a3cad48d6c5d25cb5"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#adc3a3679ad9faa3a3cad48d6c5d25cb5">hexdump</a> (const void *data, size_t len)</td></tr>
<tr class="memdesc:adc3a3679ad9faa3a3cad48d6c5d25cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turn a string into a double-length sequence of hex nibbles. <br /></td></tr>
<tr class="separator:adc3a3679ad9faa3a3cad48d6c5d25cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5176c875b34ea63dbef6dafa2ae244a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5176c875b34ea63dbef6dafa2ae244a8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a5176c875b34ea63dbef6dafa2ae244a8">xdr_to_string</a> (const T &amp;t, const char *name=nullptr, int indent=0)</td></tr>
<tr class="memdesc:a5176c875b34ea63dbef6dafa2ae244a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a std::string containing a pretty-printed version an XDR data type.  <a href="#a5176c875b34ea63dbef6dafa2ae244a8">More...</a><br /></td></tr>
<tr class="separator:a5176c875b34ea63dbef6dafa2ae244a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0aac2fadebebe95911017096a8ccc9"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd0aac2fadebebe95911017096a8ccc9"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::valid, std::ostream &amp; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#abd0aac2fadebebe95911017096a8ccc9">operator&lt;&lt;</a> (std::ostream &amp;os, const T &amp;t)</td></tr>
<tr class="memdesc:abd0aac2fadebebe95911017096a8ccc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print an arbitrary XDR structure to a <code>std::ostream</code>.  <a href="#abd0aac2fadebebe95911017096a8ccc9">More...</a><br /></td></tr>
<tr class="separator:abd0aac2fadebebe95911017096a8ccc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a27b017e349df73ef996b9f6431f2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a29a27b017e349df73ef996b9f6431f2f">tcp_connect_rpc</a> (const char *host, std::uint32_t prog, std::uint32_t vers, int family=AF_UNSPEC)</td></tr>
<tr class="memdesc:a29a27b017e349df73ef996b9f6431f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TCP connection to an RPC server on <code>host</code>, first querying <code>rpcbind</code> on <code>host</code> to determine the port.  <a href="#a29a27b017e349df73ef996b9f6431f2f">More...</a><br /></td></tr>
<tr class="separator:a29a27b017e349df73ef996b9f6431f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb5fda0ea9afddd9e802af200c2b05f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a1cb5fda0ea9afddd9e802af200c2b05f">parse_uaddr_port</a> (const string &amp;uaddr)</td></tr>
<tr class="memdesc:a1cb5fda0ea9afddd9e802af200c2b05f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the port number from an RFC1833 / RFC5665 universal network address (uaddr).  <a href="#a1cb5fda0ea9afddd9e802af200c2b05f">More...</a><br /></td></tr>
<tr class="separator:a1cb5fda0ea9afddd9e802af200c2b05f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e40023edb05a12f9ff763c128c97b2"><td class="memItemLeft" align="right" valign="top"><a id="af0e40023edb05a12f9ff763c128c97b2"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#af0e40023edb05a12f9ff763c128c97b2">make_uaddr</a> (const sockaddr *sa, socklen_t salen)</td></tr>
<tr class="memdesc:af0e40023edb05a12f9ff763c128c97b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a uaddr for a local address or file descriptor. <br /></td></tr>
<tr class="separator:af0e40023edb05a12f9ff763c128c97b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369e1a5a9e6d832b09f1547beef477a1"><td class="memItemLeft" align="right" valign="top"><a id="a369e1a5a9e6d832b09f1547beef477a1"></a>
string&#160;</td><td class="memItemRight" valign="bottom"><b>make_uaddr</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s)</td></tr>
<tr class="separator:a369e1a5a9e6d832b09f1547beef477a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbc80d4ea844386ff914e882fb4b1a9"><td class="memItemLeft" align="right" valign="top"><a id="a0fbc80d4ea844386ff914e882fb4b1a9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a0fbc80d4ea844386ff914e882fb4b1a9">rpcbind_register</a> (const sockaddr *sa, socklen_t salen, std::uint32_t prog, std::uint32_t vers)</td></tr>
<tr class="memdesc:a0fbc80d4ea844386ff914e882fb4b1a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a service listening on <code>sa</code> with <code>rpcbind</code>. <br /></td></tr>
<tr class="separator:a0fbc80d4ea844386ff914e882fb4b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a672a1ce7db0e76e2266d532a56d0b516"><td class="memItemLeft" align="right" valign="top"><a id="a672a1ce7db0e76e2266d532a56d0b516"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>rpcbind_register</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, std::uint32_t prog, std::uint32_t vers)</td></tr>
<tr class="separator:a672a1ce7db0e76e2266d532a56d0b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f55ca683e40f6944f7f1a1cf1b95517"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a3f55ca683e40f6944f7f1a1cf1b95517">parse_uaddr_port</a> (const std::string &amp;uaddr)</td></tr>
<tr class="memdesc:a3f55ca683e40f6944f7f1a1cf1b95517"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the port number from an RFC1833 / RFC5665 universal network address (uaddr).  <a href="#a3f55ca683e40f6944f7f1a1cf1b95517">More...</a><br /></td></tr>
<tr class="separator:a3f55ca683e40f6944f7f1a1cf1b95517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3848bf6283d1b103365fee4f5f3bc2b9"><td class="memItemLeft" align="right" valign="top"><a id="a3848bf6283d1b103365fee4f5f3bc2b9"></a>
msg_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>rpc_accepted_error_msg</b> (uint32_t xid, accept_stat stat)</td></tr>
<tr class="separator:a3848bf6283d1b103365fee4f5f3bc2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d99085e698da1bd5064a50bdb591a4b"><td class="memItemLeft" align="right" valign="top"><a id="a7d99085e698da1bd5064a50bdb591a4b"></a>
msg_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>rpc_prog_mismatch_msg</b> (uint32_t xid, uint32_t low, uint32_t high)</td></tr>
<tr class="separator:a7d99085e698da1bd5064a50bdb591a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4fe1cafda1fac1fa5657ae353d749d"><td class="memItemLeft" align="right" valign="top"><a id="a2d4fe1cafda1fac1fa5657ae353d749d"></a>
msg_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>rpc_auth_error_msg</b> (uint32_t xid, auth_stat stat)</td></tr>
<tr class="separator:a2d4fe1cafda1fac1fa5657ae353d749d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b15a84a97ee05d58fd0042df6b1791"><td class="memItemLeft" align="right" valign="top"><a id="ac0b15a84a97ee05d58fd0042df6b1791"></a>
msg_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>rpc_rpc_mismatch_msg</b> (uint32_t xid)</td></tr>
<tr class="separator:ac0b15a84a97ee05d58fd0042df6b1791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b34b8a8bcc6dab815532881c53009c"><td class="memTemplParams" colspan="2"><a id="a47b34b8a8bcc6dab815532881c53009c"></a>
template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a47b34b8a8bcc6dab815532881c53009c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>archive</b> (Archive &amp;ar, const <a class="el" href="structxdr_1_1transparent__ptr.html">transparent_ptr</a>&lt; T &gt; &amp;t, const char *name=nullptr)</td></tr>
<tr class="separator:a47b34b8a8bcc6dab815532881c53009c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e80c50616c751ad4681ce3a430f07d"><td class="memTemplParams" colspan="2">template&lt;typename P , typename C , typename S , typename T , typename... Rest&gt; </td></tr>
<tr class="memitem:a92e80c50616c751ad4681ce3a430f07d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a92e80c50616c751ad4681ce3a430f07d">dispatch_with_session</a> (C &amp;&amp;c, S *s, T &amp;&amp;t, Rest &amp;&amp;...rest) -&gt; decltype(detail::dispatch_session_helper&lt; P, C, T &gt;::dispatch(c, s, std::forward&lt; T &gt;(t), std::forward&lt; Rest &gt;(rest)...))</td></tr>
<tr class="memdesc:a92e80c50616c751ad4681ce3a430f07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <code>P::dispatch</code> with a session pointer (unless the session type <code>S</code> is void, in which case the argument is omitted) and with a tuple that should be unpacked into multiple arguments.  <a href="#a92e80c50616c751ad4681ce3a430f07d">More...</a><br /></td></tr>
<tr class="separator:a92e80c50616c751ad4681ce3a430f07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5da33a5bb0905335ef22b0deb90f846"><td class="memItemLeft" align="right" valign="top"><a id="ad5da33a5bb0905335ef22b0deb90f846"></a>
const std::error_category &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#ad5da33a5bb0905335ef22b0deb90f846">gai_category</a> ()</td></tr>
<tr class="memdesc:ad5da33a5bb0905335ef22b0deb90f846"><td class="mdescLeft">&#160;</td><td class="mdescRight">Category for system errors dealing with DNS (getaddrinfo, etc.). <br /></td></tr>
<tr class="separator:ad5da33a5bb0905335ef22b0deb90f846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7fac5da0fb2f354925b820825cf4b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacexdr.html#a68b183e470bc78ebaa3d03b86dda2aa9">unique_addrinfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#afb7fac5da0fb2f354925b820825cf4b0">get_addrinfo</a> (const char *host, int socktype=SOCK_STREAM, const char *service=nullptr, int family=AF_UNSPEC)</td></tr>
<tr class="memdesc:afb7fac5da0fb2f354925b820825cf4b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around <code>getaddrinfo</code> that returns a garbage-collected <a class="el" href="namespacexdr.html#a68b183e470bc78ebaa3d03b86dda2aa9" title="Automatically garbage-collected addrinfo pointer. ">xdr::unique_addrinfo</a>.  <a href="#afb7fac5da0fb2f354925b820825cf4b0">More...</a><br /></td></tr>
<tr class="separator:afb7fac5da0fb2f354925b820825cf4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d12a47b3a20882a6463699ce6216ea6"><td class="memItemLeft" align="right" valign="top"><a id="a7d12a47b3a20882a6463699ce6216ea6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a7d12a47b3a20882a6463699ce6216ea6">get_numinfo</a> (const sockaddr *sa, socklen_t salen, string *host, string *serv)</td></tr>
<tr class="memdesc:a7d12a47b3a20882a6463699ce6216ea6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return printable versions of numeric host and port number. <br /></td></tr>
<tr class="separator:a7d12a47b3a20882a6463699ce6216ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c40ec18114b7c56d22750fd4b8851b"><td class="memItemLeft" align="right" valign="top"><a id="a27c40ec18114b7c56d22750fd4b8851b"></a>
<a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a27c40ec18114b7c56d22750fd4b8851b">tcp_connect1</a> (const addrinfo *ai, bool ndelay=false)</td></tr>
<tr class="memdesc:a27c40ec18114b7c56d22750fd4b8851b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try connecting to the first <b>addrinfo</b> in a linked list. <br /></td></tr>
<tr class="separator:a27c40ec18114b7c56d22750fd4b8851b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f0054c05a719e73e8d5d6589d864ff"><td class="memItemLeft" align="right" valign="top"><a id="a72f0054c05a719e73e8d5d6589d864ff"></a>
<a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a72f0054c05a719e73e8d5d6589d864ff">tcp_connect</a> (const addrinfo *ai)</td></tr>
<tr class="memdesc:a72f0054c05a719e73e8d5d6589d864ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try connecting to every <b>addrinfo</b> in a list until one succeeds. <br /></td></tr>
<tr class="separator:a72f0054c05a719e73e8d5d6589d864ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af862534ef3ef2631485697b7ecf038e7"><td class="memItemLeft" align="right" valign="top"><a id="af862534ef3ef2631485697b7ecf038e7"></a>
<a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_connect</b> (const char *host, const char *service, int family)</td></tr>
<tr class="separator:af862534ef3ef2631485697b7ecf038e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19559f5c53584d49690056b9c7e970cc"><td class="memItemLeft" align="right" valign="top"><a id="a19559f5c53584d49690056b9c7e970cc"></a>
<a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a19559f5c53584d49690056b9c7e970cc">tcp_listen</a> (const char *service=&quot;0&quot;, int family=AF_UNSPEC, int backlog=5)</td></tr>
<tr class="memdesc:a19559f5c53584d49690056b9c7e970cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create bind a listening TCP socket. <br /></td></tr>
<tr class="separator:a19559f5c53584d49690056b9c7e970cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c409615e4ba30a5a5737f78f4b23b57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a9c409615e4ba30a5a5737f78f4b23b57">sock_eagain</a> ()</td></tr>
<tr class="memdesc:a9c409615e4ba30a5a5737f78f4b23b57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the most recent (socket) error is a temporary error, such as EAGAIN, EWOULDBLOCK, or EINTR.  <a href="#a9c409615e4ba30a5a5737f78f4b23b57">More...</a><br /></td></tr>
<tr class="separator:a9c409615e4ba30a5a5737f78f4b23b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9fbe0c844bef850a75632d93ba9976"><td class="memItemLeft" align="right" valign="top"><a id="aae9fbe0c844bef850a75632d93ba9976"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aae9fbe0c844bef850a75632d93ba9976">sock_errmsg</a> ()</td></tr>
<tr class="memdesc:aae9fbe0c844bef850a75632d93ba9976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last socket error message (<code>strerror(errno)</code> on POSIX). <br /></td></tr>
<tr class="separator:aae9fbe0c844bef850a75632d93ba9976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be8527a351927d9c964f958f929e5e2"><td class="memItemLeft" align="right" valign="top"><a id="a7be8527a351927d9c964f958f929e5e2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a7be8527a351927d9c964f958f929e5e2">throw_sockerr</a> (const char *)</td></tr>
<tr class="memdesc:a7be8527a351927d9c964f958f929e5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a <code>system_error</code> exception for the last socket error. <br /></td></tr>
<tr class="separator:a7be8527a351927d9c964f958f929e5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eed7174aa78c3d14e39816a8ac1aba"><td class="memItemLeft" align="right" valign="top"><a id="a98eed7174aa78c3d14e39816a8ac1aba"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>read</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, void *buf, std::size_t count)</td></tr>
<tr class="separator:a98eed7174aa78c3d14e39816a8ac1aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc3d88fd7a8fe1007c8f6a2e32e5d562"><td class="memItemLeft" align="right" valign="top"><a id="afc3d88fd7a8fe1007c8f6a2e32e5d562"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>write</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, const void *buf, std::size_t count)</td></tr>
<tr class="separator:afc3d88fd7a8fe1007c8f6a2e32e5d562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0c5fa747c1073b4425003bda94489c"><td class="memItemLeft" align="right" valign="top"><a id="a3f0c5fa747c1073b4425003bda94489c"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>readv</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="separator:a3f0c5fa747c1073b4425003bda94489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45061c3fd41c9da73ede81af21946452"><td class="memItemLeft" align="right" valign="top"><a id="a45061c3fd41c9da73ede81af21946452"></a>
ssize_t&#160;</td><td class="memItemRight" valign="bottom"><b>writev</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, const struct iovec *iov, int iovcnt)</td></tr>
<tr class="separator:a45061c3fd41c9da73ede81af21946452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f822e53ad00aa7d6c6f7a0442b9212b"><td class="memItemLeft" align="right" valign="top"><a id="a4f822e53ad00aa7d6c6f7a0442b9212b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>close</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s)</td></tr>
<tr class="separator:a4f822e53ad00aa7d6c6f7a0442b9212b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a801c43d8d25fb878be3fba1302bfc2b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a801c43d8d25fb878be3fba1302bfc2b2">set_nonblock</a> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s)</td></tr>
<tr class="memdesc:a801c43d8d25fb878be3fba1302bfc2b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the <code>O_NONBLOCK</code> flag on a socket.  <a href="#a801c43d8d25fb878be3fba1302bfc2b2">More...</a><br /></td></tr>
<tr class="separator:a801c43d8d25fb878be3fba1302bfc2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3838219eb7d66218f5e0b1cb0e18c0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a3838219eb7d66218f5e0b1cb0e18c0fd">set_close_on_exec</a> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s)</td></tr>
<tr class="memdesc:a3838219eb7d66218f5e0b1cb0e18c0fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the close-on-exec flag of a file descriptor.  <a href="#a3838219eb7d66218f5e0b1cb0e18c0fd">More...</a><br /></td></tr>
<tr class="separator:a3838219eb7d66218f5e0b1cb0e18c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de882f4a23db3fd00b13128f63d22cf"><td class="memItemLeft" align="right" valign="top"><a id="a4de882f4a23db3fd00b13128f63d22cf"></a>
<a class="el" href="structxdr_1_1sock__t.html">sock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a4de882f4a23db3fd00b13128f63d22cf">accept</a> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:a4de882f4a23db3fd00b13128f63d22cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrapper around accept for <a class="el" href="structxdr_1_1sock__t.html" title="Abstract away the type of a socket (for windows). ">sock_t</a>. <br /></td></tr>
<tr class="separator:a4de882f4a23db3fd00b13128f63d22cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5765243b958d537f42fca8a724259f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#adc5765243b958d537f42fca8a724259f">create_selfpipe</a> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> ss[2])</td></tr>
<tr class="memdesc:adc5765243b958d537f42fca8a724259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a socket (or pipe on unix, where both are file descriptors) that is connected to itself.  <a href="#adc5765243b958d537f42fca8a724259f">More...</a><br /></td></tr>
<tr class="separator:adc5765243b958d537f42fca8a724259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0892133c93f250b8c705268f843ff62a"><td class="memItemLeft" align="right" valign="top"><a id="a0892133c93f250b8c705268f843ff62a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a0892133c93f250b8c705268f843ff62a">get_numinfo</a> (const sockaddr *sa, socklen_t salen, std::string *host, std::string *serv)</td></tr>
<tr class="memdesc:a0892133c93f250b8c705268f843ff62a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return printable versions of numeric host and port number. <br /></td></tr>
<tr class="separator:a0892133c93f250b8c705268f843ff62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649a4580618da6fd601e99e8883e7492"><td class="memItemLeft" align="right" valign="top"><a id="a649a4580618da6fd601e99e8883e7492"></a>
<a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a>&#160;</td><td class="memItemRight" valign="bottom"><b>tcp_connect</b> (const <a class="el" href="namespacexdr.html#a68b183e470bc78ebaa3d03b86dda2aa9">unique_addrinfo</a> &amp;ai)</td></tr>
<tr class="separator:a649a4580618da6fd601e99e8883e7492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a424cce9a0ed222ecea80b0cb690cc107"><td class="memItemLeft" align="right" valign="top"><a id="a424cce9a0ed222ecea80b0cb690cc107"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>sock_eof</b> ()</td></tr>
<tr class="separator:a424cce9a0ed222ecea80b0cb690cc107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6e18678248cf95a24290a0b4357aa9"><td class="memItemLeft" align="right" valign="top"><a id="a7b6e18678248cf95a24290a0b4357aa9"></a>
msg_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>read_message</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s)</td></tr>
<tr class="separator:a7b6e18678248cf95a24290a0b4357aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853519956159a3e1e960fb0c7dcf9f85"><td class="memItemLeft" align="right" valign="top"><a id="a853519956159a3e1e960fb0c7dcf9f85"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>write_message</b> (<a class="el" href="structxdr_1_1sock__t.html">sock_t</a> s, const msg_ptr &amp;m)</td></tr>
<tr class="separator:a853519956159a3e1e960fb0c7dcf9f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac327e34a9bd0d82676e027280c9c51d2"><td class="memItemLeft" align="right" valign="top"><a id="ac327e34a9bd0d82676e027280c9c51d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>prepare_call</b> (uint32_t prog, uint32_t vers, uint32_t proc, <a class="el" href="structxdr_1_1rpc__msg.html">rpc_msg</a> &amp;hdr)</td></tr>
<tr class="separator:ac327e34a9bd0d82676e027280c9c51d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81a1b3ae886053001228ab3cd4bed57"><td class="memTemplParams" colspan="2"><a id="aa81a1b3ae886053001228ab3cd4bed57"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:aa81a1b3ae886053001228ab3cd4bed57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prepare_call</b> (<a class="el" href="structxdr_1_1rpc__msg.html">rpc_msg</a> &amp;hdr)</td></tr>
<tr class="separator:aa81a1b3ae886053001228ab3cd4bed57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39078b69403c4180075e8e0a6ed1b8c"><td class="memItemLeft" align="right" valign="top"><a id="af39078b69403c4180075e8e0a6ed1b8c"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>size32</b> (std::size_t s)</td></tr>
<tr class="separator:af39078b69403c4180075e8e0a6ed1b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7c4c84c79a69d0bad433bff349741a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e7c4c84c79a69d0bad433bff349741a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a8e7c4c84c79a69d0bad433bff349741a">validate</a> (const T &amp;t)</td></tr>
<tr class="memdesc:a8e7c4c84c79a69d0bad433bff349741a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If this function template is specialized, it provides a means of placing extra restrictions on XDR data structures (beyond those of the XDR specification).  <a href="#a8e7c4c84c79a69d0bad433bff349741a">More...</a><br /></td></tr>
<tr class="separator:a8e7c4c84c79a69d0bad433bff349741a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c8a370f4f726fc09e8b491aa9c597d"><td class="memTemplParams" colspan="2">template&lt;typename Archive , typename T &gt; </td></tr>
<tr class="memitem:a83c8a370f4f726fc09e8b491aa9c597d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a83c8a370f4f726fc09e8b491aa9c597d">archive</a> (Archive &amp;ar, T &amp;&amp;t, const char *name=nullptr)</td></tr>
<tr class="memdesc:a83c8a370f4f726fc09e8b491aa9c597d"><td class="mdescLeft">&#160;</td><td class="mdescRight">By default, this function simply applies <code>ar</code> (which must be a function object) to <code>t</code>.  <a href="#a83c8a370f4f726fc09e8b491aa9c597d">More...</a><br /></td></tr>
<tr class="separator:a83c8a370f4f726fc09e8b491aa9c597d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d7d468ca38567936bd06d4297541fb"><td class="memTemplParams" colspan="2"><a id="af8d7d468ca38567936bd06d4297541fb"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8d7d468ca38567936bd06d4297541fb"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#af8d7d468ca38567936bd06d4297541fb">xdr_size</a> (const T &amp;t)</td></tr>
<tr class="memdesc:af8d7d468ca38567936bd06d4297541fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the marshaled size of an XDR data type. <br /></td></tr>
<tr class="separator:af8d7d468ca38567936bd06d4297541fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c46504e7ed6a829128f06a8d2ec591"><td class="memTemplParams" colspan="2">template&lt;typename To , typename From &gt; </td></tr>
<tr class="memitem:a74c46504e7ed6a829128f06a8d2ec591"><td class="memTemplItemLeft" align="right" valign="top">To&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a74c46504e7ed6a829128f06a8d2ec591">xdr_reinterpret</a> (From f)</td></tr>
<tr class="memdesc:a74c46504e7ed6a829128f06a8d2ec591"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reinterpret-cast like function that works between types such as floating-point and integers of the same size.  <a href="#a74c46504e7ed6a829128f06a8d2ec591">More...</a><br /></td></tr>
<tr class="separator:a74c46504e7ed6a829128f06a8d2ec591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_struct &amp;&amp;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65">operator==</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality for XDR structures.  <a href="#aa2d8c028a76a0f1e55bf501fc3c1ec65">More...</a><br /></td></tr>
<tr class="separator:aa2d8c028a76a0f1e55bf501fc3c1ec65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a295aa6d992235dcacf9851fe3df2f1c4"><td class="memTemplParams" colspan="2"><a id="a295aa6d992235dcacf9851fe3df2f1c4"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a295aa6d992235dcacf9851fe3df2f1c4"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_struct &amp;&amp;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a295aa6d992235dcacf9851fe3df2f1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c2146d23782d298ca4c29ed4a73fba"><td class="memTemplParams" colspan="2"><a id="a41c2146d23782d298ca4c29ed4a73fba"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41c2146d23782d298ca4c29ed4a73fba"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_struct &amp;&amp;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a41c2146d23782d298ca4c29ed4a73fba">operator&lt;</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a41c2146d23782d298ca4c29ed4a73fba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering of XDR structures. See note at <code><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65" title="Equality for XDR structures. ">xdr::operator==</a></code>. <br /></td></tr>
<tr class="separator:a41c2146d23782d298ca4c29ed4a73fba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d4168bf3ea7ae1fd45bb1b0cf00c64"><td class="memTemplParams" colspan="2"><a id="a56d4168bf3ea7ae1fd45bb1b0cf00c64"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a56d4168bf3ea7ae1fd45bb1b0cf00c64"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_struct &amp;&amp;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a56d4168bf3ea7ae1fd45bb1b0cf00c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59902ec960fe04e2ae7bda5862ff23ef"><td class="memTemplParams" colspan="2"><a id="a59902ec960fe04e2ae7bda5862ff23ef"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59902ec960fe04e2ae7bda5862ff23ef"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_struct &amp;&amp;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a59902ec960fe04e2ae7bda5862ff23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b4f3ca2ca0c2a74409fc45e67e8823c"><td class="memTemplParams" colspan="2"><a id="a2b4f3ca2ca0c2a74409fc45e67e8823c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2b4f3ca2ca0c2a74409fc45e67e8823c"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_struct &amp;&amp;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::xdr_defined, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&gt;=</b> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="separator:a2b4f3ca2ca0c2a74409fc45e67e8823c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8ca76bb3329e159c771984714a890a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c8ca76bb3329e159c771984714a890a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_union, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a9c8ca76bb3329e159c771984714a890a">operator==</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a9c8ca76bb3329e159c771984714a890a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality of XDR unions.  <a href="#a9c8ca76bb3329e159c771984714a890a">More...</a><br /></td></tr>
<tr class="separator:a9c8ca76bb3329e159c771984714a890a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1625a660b09dc7875a814c8ac98493"><td class="memTemplParams" colspan="2"><a id="a1c1625a660b09dc7875a814c8ac98493"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1c1625a660b09dc7875a814c8ac98493"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt; T &gt;::is_union, bool &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a1c1625a660b09dc7875a814c8ac98493">operator&lt;</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:a1c1625a660b09dc7875a814c8ac98493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordering of XDR unions. See note at <code><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65" title="Equality for XDR structures. ">xdr::operator==</a></code>. <br /></td></tr>
<tr class="separator:a1c1625a660b09dc7875a814c8ac98493"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ad25a857263905147ab6462589d24a183"><td class="memItemLeft" align="right" valign="top"><a id="ad25a857263905147ab6462589d24a183"></a>
Constexpr const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#ad25a857263905147ab6462589d24a183">is_big_endian</a> = false</td></tr>
<tr class="memdesc:ad25a857263905147ab6462589d24a183"><td class="mdescLeft">&#160;</td><td class="mdescRight">True on big endian machines, false on little endian machines. <br /></td></tr>
<tr class="separator:ad25a857263905147ab6462589d24a183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a773c6afe230a6a8633815240b421ef61"><td class="memItemLeft" align="right" valign="top"><a id="a773c6afe230a6a8633815240b421ef61"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>RPCB_PORT</b> = 111</td></tr>
<tr class="separator:a773c6afe230a6a8633815240b421ef61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0eaea76206ecdb06b5cc84aaea61769"><td class="memItemLeft" align="right" valign="top"><a id="aa0eaea76206ecdb06b5cc84aaea61769"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>rpcb_highproc_2</b> = 5</td></tr>
<tr class="separator:aa0eaea76206ecdb06b5cc84aaea61769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe2e2d8572b0dcab968ce2237c0eb64"><td class="memItemLeft" align="right" valign="top"><a id="a9fe2e2d8572b0dcab968ce2237c0eb64"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>rpcb_highproc_3</b> = 8</td></tr>
<tr class="separator:a9fe2e2d8572b0dcab968ce2237c0eb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd0ceb7b1a3f31ff6c34aa1eb2c450b"><td class="memItemLeft" align="right" valign="top"><a id="adfd0ceb7b1a3f31ff6c34aa1eb2c450b"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>rpcb_highproc_4</b> = 12</td></tr>
<tr class="separator:adfd0ceb7b1a3f31ff6c34aa1eb2c450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2814378282bcf375ba929f2e32174769"><td class="memItemLeft" align="right" valign="top"><a id="a2814378282bcf375ba929f2e32174769"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>RPCBSTAT_HIGHPROC</b> = 13</td></tr>
<tr class="separator:a2814378282bcf375ba929f2e32174769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aac4e08101ba258172cf07a081ba934"><td class="memItemLeft" align="right" valign="top"><a id="a1aac4e08101ba258172cf07a081ba934"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>RPCBVERS_STAT</b> = 3</td></tr>
<tr class="separator:a1aac4e08101ba258172cf07a081ba934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc649a6cefe8f7641632c6ec1b453478"><td class="memItemLeft" align="right" valign="top"><a id="adc649a6cefe8f7641632c6ec1b453478"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>RPCBVERS_4_STAT</b> = 2</td></tr>
<tr class="separator:adc649a6cefe8f7641632c6ec1b453478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c53e846514cda585262333cd794af0"><td class="memItemLeft" align="right" valign="top"><a id="a71c53e846514cda585262333cd794af0"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>RPCBVERS_3_STAT</b> = 1</td></tr>
<tr class="separator:a71c53e846514cda585262333cd794af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d497c61c2b5a4e11ddbce7c944a01f"><td class="memItemLeft" align="right" valign="top"><a id="a34d497c61c2b5a4e11ddbce7c944a01f"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>RPCBVERS_2_STAT</b> = 0</td></tr>
<tr class="separator:a34d497c61c2b5a4e11ddbce7c944a01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6db4e4ef3c9ee810fc9fa2b72a7c10d"><td class="memItemLeft" align="right" valign="top"><a id="ad6db4e4ef3c9ee810fc9fa2b72a7c10d"></a>
Constexpr const std::uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>PMAP_PORT</b> = 111</td></tr>
<tr class="separator:ad6db4e4ef3c9ee810fc9fa2b72a7c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718c8697d9400bd9ed9a50a72435dc47"><td class="memItemLeft" align="right" valign="top"><a id="a718c8697d9400bd9ed9a50a72435dc47"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xdr_trace_server</b> = std::getenv(&quot;XDR_TRACE_SERVER&quot;)</td></tr>
<tr class="separator:a718c8697d9400bd9ed9a50a72435dc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08166d78d6bd6db2ce4d1e6596cc74cc"><td class="memItemLeft" align="right" valign="top"><a id="a08166d78d6bd6db2ce4d1e6596cc74cc"></a>
constexpr <a class="el" href="structxdr_1_1sock__t.html">sock_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>invalid_sock</b> {}</td></tr>
<tr class="separator:a08166d78d6bd6db2ce4d1e6596cc74cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fb7de40b4eef2f576ee716960bb049"><td class="memItemLeft" align="right" valign="top"><a id="ae9fb7de40b4eef2f576ee716960bb049"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xdr_trace_client</b> = std::getenv(&quot;XDR_TRACE_CLIENT&quot;)</td></tr>
<tr class="separator:ae9fb7de40b4eef2f576ee716960bb049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab39d6cc07aaaff0c8f77776fe232a0ba"><td class="memItemLeft" align="right" valign="top"><a id="ab39d6cc07aaaff0c8f77776fe232a0ba"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>xid_counter</b></td></tr>
<tr class="separator:ab39d6cc07aaaff0c8f77776fe232a0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e71e2866065709507c9987df76cdf1"><td class="memItemLeft" align="right" valign="top">Constexpr const <a class="el" href="structxdr_1_1field__constructor__t.html">field_constructor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a83e71e2866065709507c9987df76cdf1">field_constructor</a> {}</td></tr>
<tr class="memdesc:a83e71e2866065709507c9987df76cdf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to the auto-generated _xdr_with_mem_ptr static method to construct the active union field (or at least the union field corresponding to the second argument to _xdr_with_mem_ptr, which should be the active union field).  <a href="#a83e71e2866065709507c9987df76cdf1">More...</a><br /></td></tr>
<tr class="separator:a83e71e2866065709507c9987df76cdf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5269831a7acba49000c6b3c6410481"><td class="memItemLeft" align="right" valign="top"><a id="a8a5269831a7acba49000c6b3c6410481"></a>
Constexpr const <a class="el" href="structxdr_1_1field__destructor__t.html">field_destructor_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a8a5269831a7acba49000c6b3c6410481">field_destructor</a> {}</td></tr>
<tr class="memdesc:a8a5269831a7acba49000c6b3c6410481"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to destroy the active union field. <br /></td></tr>
<tr class="separator:a8a5269831a7acba49000c6b3c6410481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c83bc2f32f255bcdf81fe95a6cf7726"><td class="memItemLeft" align="right" valign="top"><a id="a9c83bc2f32f255bcdf81fe95a6cf7726"></a>
Constexpr const <a class="el" href="structxdr_1_1field__assigner__t.html">field_assigner_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a9c83bc2f32f255bcdf81fe95a6cf7726">field_assigner</a> {}</td></tr>
<tr class="memdesc:a9c83bc2f32f255bcdf81fe95a6cf7726"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to assign to the active union field. <br /></td></tr>
<tr class="separator:a9c83bc2f32f255bcdf81fe95a6cf7726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187692134e50a318d5159f3a014e92d7"><td class="memItemLeft" align="right" valign="top"><a id="a187692134e50a318d5159f3a014e92d7"></a>
Constexpr const <a class="el" href="structxdr_1_1field__archiver__t.html">field_archiver_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a187692134e50a318d5159f3a014e92d7">field_archiver</a> {}</td></tr>
<tr class="memdesc:a187692134e50a318d5159f3a014e92d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to archive the active union field. <br /></td></tr>
<tr class="separator:a187692134e50a318d5159f3a014e92d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33ac39dce2cf36ae6fdaa09f47e7a6a0"><td class="memItemLeft" align="right" valign="top">Constexpr const <a class="el" href="structxdr_1_1field__size__t.html">field_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacexdr.html#a33ac39dce2cf36ae6fdaa09f47e7a6a0">field_size</a> {}</td></tr>
<tr class="memdesc:a33ac39dce2cf36ae6fdaa09f47e7a6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Passed to _xdr_with_mem_ptr to compute the size of the active union field.  <a href="#a33ac39dce2cf36ae6fdaa09f47e7a6a0">More...</a><br /></td></tr>
<tr class="separator:a33ac39dce2cf36ae6fdaa09f47e7a6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Most of the xdrpp library is encapsulated in the xdr namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a7e7bd9c2f3e417b290472c3b1ef28884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7bd9c2f3e417b290472c3b1ef28884">&#9670;&nbsp;</a></span>wrap_transparent_ptr</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacexdr.html#a7e7bd9c2f3e417b290472c3b1ef28884">xdr::wrap_transparent_ptr</a> = typedef typename detail::wrap_transparent_ptr_helper&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap <a class="el" href="structxdr_1_1transparent__ptr.html" title="A pointer, but that gets marshalled as the underlying object and can convert to the underlying type...">xdr::transparent_ptr</a> around each type in a tuple to generate a new tuple type. </p>

<p class="definition">Definition at line <a class="el" href="server_8h_source.html#l00118">118</a> of file <a class="el" href="server_8h_source.html">server.h</a>.</p>

</div>
</div>
<a id="a665952498b5c2be139ae076f5f9cd724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665952498b5c2be139ae076f5f9cd724">&#9670;&nbsp;</a></span>srpc_client</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacexdr.html#a665952498b5c2be139ae076f5f9cd724">xdr::srpc_client</a> = typedef typename T::template _xdr_client&lt;<a class="el" href="classxdr_1_1synchronous__client__base.html">synchronous_client_base</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an RPC client from an interface type and connected stream socket. </p>
<p>Note that the file descriptor is not closed afterwards (as you may wish to use different interfaces over the same file descriptor). A simple example looks like this:</p>
<div class="fragment"><div class="line">unique_fd fd = <a class="code" href="namespacexdr.html#a29a27b017e349df73ef996b9f6431f2f">tcp_connect_rpc</a>(argc &gt; 2 ? argv[2] : <span class="keyword">nullptr</span>,</div><div class="line">                               MyProg1::program, MyProg1::version);</div><div class="line">srpc_client&lt;MyProg1&gt; c{fd.get()};</div><div class="line">unique_ptr&lt;big_string&gt; result = c.hello(5);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="srpc_8h_source.html#l00095">95</a> of file <a class="el" href="srpc_8h_source.html">srpc.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a59284e4264367ff7e7f8a2aa4fb747b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59284e4264367ff7e7f8a2aa4fb747b0">&#9670;&nbsp;</a></span>xdr_clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xdr::xdr_clear </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset XDR data structure to its default contents. </p>
<p>All vectors and strings are set to length 0, all fixed-size opaque arrays zeroed out, and all numeric and enum types sent to their default values (generally 0). </p>

<p class="definition">Definition at line <a class="el" href="clear_8h_source.html#l00055">55</a> of file <a class="el" href="clear_8h_source.html">clear.h</a>.</p>

</div>
</div>
<a id="a605445f875b34ef7516d6ebf443d66f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605445f875b34ef7516d6ebf443d66f6">&#9670;&nbsp;</a></span>swap32le()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Constexpr std::uint32_t xdr::swap32le </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Byteswap 32-bit value only on little-endian machines, identity function on big-endian machines. </p>

<p class="definition">Definition at line <a class="el" href="endian_8h_source.html#l00078">78</a> of file <a class="el" href="endian_8h_source.html">endian.h</a>.</p>

</div>
</div>
<a id="a65cae979b12b9ac90019d9e5bddfc910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cae979b12b9ac90019d9e5bddfc910">&#9670;&nbsp;</a></span>rpc_errmsg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xdr::rpc_errmsg </td>
          <td>(</td>
          <td class="paramtype">accept_stat&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate one of the conditions in <a href="https://tools.ietf.org/html/rfc5531">RFC5531</a> for an unexecuted call into a string. </p>

<p class="definition">Definition at line <a class="el" href="rpc__msg_8cc_source.html#l00010">10</a> of file <a class="el" href="rpc__msg_8cc_source.html">rpc_msg.cc</a>.</p>

</div>
</div>
<a id="aff0799b0b3dcdbc6f9f01a2cb284609a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0799b0b3dcdbc6f9f01a2cb284609a">&#9670;&nbsp;</a></span>rpc_errmsg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * xdr::rpc_errmsg </td>
          <td>(</td>
          <td class="paramtype">auth_stat&#160;</td>
          <td class="paramname"><em>ev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translate one of the conditions in <a href="https://tools.ietf.org/html/rfc5531">RFC5531</a> for an unexecuted call into a string. </p>

<p class="definition">Definition at line <a class="el" href="rpc__msg_8cc_source.html#l00031">31</a> of file <a class="el" href="rpc__msg_8cc_source.html">rpc_msg.cc</a>.</p>

</div>
</div>
<a id="a84733139d5a17fd33d7baa75290b9282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84733139d5a17fd33d7baa75290b9282">&#9670;&nbsp;</a></span>check_call_hdr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::check_call_hdr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structxdr_1_1rpc__msg.html">rpc_msg</a> &amp;&#160;</td>
          <td class="paramname"><em>hdr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check that an RPC header precedes a result. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="structxdr_1_1xdr__call__error.html" title="This is the exception raised in an RPC client when it reaches the server and transmits a call...">xdr_call_error</a></td><td>if the reply does not contain a response. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="rpc__msg_8cc_source.html#l00115">115</a> of file <a class="el" href="rpc__msg_8cc_source.html">rpc_msg.cc</a>.</p>

</div>
</div>
<a id="a4c0792a686ac45635d0d87eaeea94626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c0792a686ac45635d0d87eaeea94626">&#9670;&nbsp;</a></span>ini_runparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::ini_runparse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacexdr.html#a9e5c7f8b19b701745ea2823cfd02df2c">IniActions</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classxdr_1_1_ini_line.html">IniLine</a> &amp;&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the ini parser. </p>
<p>Afterwards <code>a.error()</code> will tell you if there was an error. </p>

<p class="definition">Definition at line <a class="el" href="iniparse_8cc_source.html#l00171">171</a> of file <a class="el" href="iniparse_8cc_source.html">iniparse.cc</a>.</p>

</div>
</div>
<a id="a862bd95cc733394bccab8cb62b07ded1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862bd95cc733394bccab8cb62b07ded1">&#9670;&nbsp;</a></span>ini_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xdr::ini_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacexdr.html#a9e5c7f8b19b701745ea2823cfd02df2c">IniActions</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the parser on a file. </p>
<p>A simple wrapper around fba::ini_runparse that opens the file. </p>

<p class="definition">Definition at line <a class="el" href="iniparse_8cc_source.html#l00207">207</a> of file <a class="el" href="iniparse_8cc_source.html">iniparse.cc</a>.</p>

</div>
</div>
<a id="a1311bd280e8506fef5e58102dc4c6764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1311bd280e8506fef5e58102dc4c6764">&#9670;&nbsp;</a></span>xdr_argpack_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t xdr::xdr_argpack_size </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sum of bytes required to marshal all of the argument values. </p>

<p class="definition">Definition at line <a class="el" href="marshal_8h_source.html#l00209">209</a> of file <a class="el" href="marshal_8h_source.html">marshal.h</a>.</p>

</div>
</div>
<a id="a93354eb4678f9f00c8bb204d5e6c38a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93354eb4678f9f00c8bb204d5e6c38a7">&#9670;&nbsp;</a></span>xdr_to_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">msg_ptr xdr::xdr_to_msg </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marshal one or a series of XDR types into a newly allocated buffer referenced xdr::msg_ptr. </p>
<p>If more than one argument is given, each XDR value is marshaled in turn. (In particular, this allows one to marshal a header followed by a message body.) </p>

<p class="definition">Definition at line <a class="el" href="marshal_8h_source.html#l00231">231</a> of file <a class="el" href="marshal_8h_source.html">marshal.h</a>.</p>

</div>
</div>
<a id="a5a6623f431944ea9e0a2158310e45622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6623f431944ea9e0a2158310e45622">&#9670;&nbsp;</a></span>xdr_to_opaque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexdr.html#aa08a12c21ae987530a9aadfdec31e593">opaque_vec</a> xdr::xdr_to_opaque </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marshal one or a series of XDR types into a newly allocated opaque structure for embedding in other XDR types. </p>

<p class="definition">Definition at line <a class="el" href="marshal_8h_source.html#l00243">243</a> of file <a class="el" href="marshal_8h_source.html">marshal.h</a>.</p>

</div>
</div>
<a id="a3196352f957cea3cca6ca44c2a72ef70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3196352f957cea3cca6ca44c2a72ef70">&#9670;&nbsp;</a></span>xdr_from_msg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void xdr::xdr_from_msg </td>
          <td>(</td>
          <td class="paramtype">const msg_ptr &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This does the reverse of <a class="el" href="namespacexdr.html#a93354eb4678f9f00c8bb204d5e6c38a7" title="Marshal one or a series of XDR types into a newly allocated buffer referenced xdr::msg_ptr. ">xdr::xdr_to_msg</a>, unmarshalling one or more types from a message. </p>
<p>Note that it throws an exception if the entire buffer is not consumed. </p>

<p class="definition">Definition at line <a class="el" href="marshal_8h_source.html#l00257">257</a> of file <a class="el" href="marshal_8h_source.html">marshal.h</a>.</p>

</div>
</div>
<a id="a1ecff6ceff74126580df8e2f130fcc37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecff6ceff74126580df8e2f130fcc37">&#9670;&nbsp;</a></span>xdr_from_opaque()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Bytes , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto xdr::xdr_from_opaque </td>
          <td>(</td>
          <td class="paramtype">const Bytes &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(detail::bytes_to_void(m.data()))
</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The reverse of <a class="el" href="namespacexdr.html#a5a6623f431944ea9e0a2158310e45622" title="Marshal one or a series of XDR types into a newly allocated opaque structure for embedding in other X...">xdr::xdr_to_opaque</a>. </p>
<p>For convenience, accepts the data in std::string and std::vector (of byte types) in addition to xdr::xdr_opaque&lt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="marshal_8h_source.html#l00276">276</a> of file <a class="el" href="marshal_8h_source.html">marshal.h</a>.</p>

</div>
</div>
<a id="aed3cf7e21f78488fe542f8a8e5793af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3cf7e21f78488fe542f8a8e5793af8">&#9670;&nbsp;</a></span>escape_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string xdr::escape_string </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use hex escapes for non-printable characters, and prefix backslashes and quotes with backslash. </p>

<p class="definition">Definition at line <a class="el" href="printer_8cc_source.html#l00008">8</a> of file <a class="el" href="printer_8cc_source.html">printer.cc</a>.</p>

</div>
</div>
<a id="a5176c875b34ea63dbef6dafa2ae244a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5176c875b34ea63dbef6dafa2ae244a8">&#9670;&nbsp;</a></span>xdr_to_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string xdr::xdr_to_string </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>indent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a std::string containing a pretty-printed version an XDR data type. </p>
<p>The string will contain multiple lines and end with a newline. </p><ul>
<li>name if non-NULL, the string begins with the name and an equals sign. </li>
<li>indent specifies a non-zero minimum indentation. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="printer_8h_source.html#l00162">162</a> of file <a class="el" href="printer_8h_source.html">printer.h</a>.</p>

</div>
</div>
<a id="abd0aac2fadebebe95911017096a8ccc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0aac2fadebebe95911017096a8ccc9">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt;T&gt;::valid, std::ostream &amp;&gt;::type xdr::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print an arbitrary XDR structure to a <code>std::ostream</code>. </p>
<p>To use this function, you will have to say <code>using <a class="el" href="namespacexdr.html#abd0aac2fadebebe95911017096a8ccc9" title="Print an arbitrary XDR structure to a std::ostream. ">xdr::operator&lt;&lt;</a></code> within the namespace of your XDR file. As per the C++ standard, a using <em>directive</em> (i.e., <code>using namespace xdr</code>) will not allow argument-dependent lookup. </p>

<p class="definition">Definition at line <a class="el" href="printer_8h_source.html#l00177">177</a> of file <a class="el" href="printer_8h_source.html">printer.h</a>.</p>

</div>
</div>
<a id="a29a27b017e349df73ef996b9f6431f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a27b017e349df73ef996b9f6431f2f">&#9670;&nbsp;</a></span>tcp_connect_rpc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classxdr_1_1unique__sock.html">unique_sock</a> xdr::tcp_connect_rpc </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>prog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>vers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>family</em> = <code>AF_UNSPEC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a TCP connection to an RPC server on <code>host</code>, first querying <code>rpcbind</code> on <code>host</code> to determine the port. </p>

<p class="definition">Definition at line <a class="el" href="rpcbind_8cc_source.html#l00038">38</a> of file <a class="el" href="rpcbind_8cc_source.html">rpcbind.cc</a>.</p>

</div>
</div>
<a id="a1cb5fda0ea9afddd9e802af200c2b05f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb5fda0ea9afddd9e802af200c2b05f">&#9670;&nbsp;</a></span>parse_uaddr_port() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xdr::parse_uaddr_port </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uaddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the port number from an RFC1833 / RFC5665 universal network address (uaddr). </p>

<p class="definition">Definition at line <a class="el" href="rpcbind_8cc_source.html#l00078">78</a> of file <a class="el" href="rpcbind_8cc_source.html">rpcbind.cc</a>.</p>

</div>
</div>
<a id="a3f55ca683e40f6944f7f1a1cf1b95517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f55ca683e40f6944f7f1a1cf1b95517">&#9670;&nbsp;</a></span>parse_uaddr_port() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int xdr::parse_uaddr_port </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>uaddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the port number from an RFC1833 / RFC5665 universal network address (uaddr). </p>

<p class="definition">Definition at line <a class="el" href="rpcbind_8cc_source.html#l00078">78</a> of file <a class="el" href="rpcbind_8cc_source.html">rpcbind.cc</a>.</p>

</div>
</div>
<a id="a92e80c50616c751ad4681ce3a430f07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e80c50616c751ad4681ce3a430f07d">&#9670;&nbsp;</a></span>dispatch_with_session()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename C , typename S , typename T , typename... Rest&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto xdr::dispatch_with_session </td>
          <td>(</td>
          <td class="paramtype">C &amp;&amp;&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Rest &amp;&amp;...&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(detail::dispatch_session_helper&lt;P, C, T&gt;::dispatch(
               c, s, std::forward&lt;T&gt;(t), std::forward&lt;Rest&gt;(rest)...))
</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call <code>P::dispatch</code> with a session pointer (unless the session type <code>S</code> is void, in which case the argument is omitted) and with a tuple that should be unpacked into multiple arguments. </p>
<p>For example, </p><div class="fragment"><div class="line">dispatch_with_session&lt;P&gt;(c, (<span class="keywordtype">void</span> *) 0, make_tuple(1, <span class="comment">//! 2), 3, 4);</span></div></div><!-- fragment --><p> is equivalent to </p><div class="fragment"><div class="line">P::dispatch(c, 1, 2, 3, 4);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="server_8h_source.html#l00165">165</a> of file <a class="el" href="server_8h_source.html">server.h</a>.</p>

</div>
</div>
<a id="afb7fac5da0fb2f354925b820825cf4b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7fac5da0fb2f354925b820825cf4b0">&#9670;&nbsp;</a></span>get_addrinfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacexdr.html#a68b183e470bc78ebaa3d03b86dda2aa9">unique_addrinfo</a> xdr::get_addrinfo </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>socktype</em> = <code>SOCK_STREAM</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>service</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>family</em> = <code>AF_UNSPEC</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrapper around <code>getaddrinfo</code> that returns a garbage-collected <a class="el" href="namespacexdr.html#a68b183e470bc78ebaa3d03b86dda2aa9" title="Automatically garbage-collected addrinfo pointer. ">xdr::unique_addrinfo</a>. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>with <a class="el" href="namespacexdr.html#ad5da33a5bb0905335ef22b0deb90f846" title="Category for system errors dealing with DNS (getaddrinfo, etc.). ">xdr::gai_category</a> on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="socket_8cc_source.html#l00070">70</a> of file <a class="el" href="socket_8cc_source.html">socket.cc</a>.</p>

</div>
</div>
<a id="a9c409615e4ba30a5a5737f78f4b23b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c409615e4ba30a5a5737f78f4b23b57">&#9670;&nbsp;</a></span>sock_eagain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool xdr::sock_eagain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the most recent (socket) error is a temporary error, such as EAGAIN, EWOULDBLOCK, or EINTR. </p>

<p class="definition">Definition at line <a class="el" href="socket__unix_8cc_source.html#l00018">18</a> of file <a class="el" href="socket__unix_8cc_source.html">socket_unix.cc</a>.</p>

</div>
</div>
<a id="a801c43d8d25fb878be3fba1302bfc2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a801c43d8d25fb878be3fba1302bfc2b2">&#9670;&nbsp;</a></span>set_nonblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::set_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxdr_1_1sock__t.html">sock_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the <code>O_NONBLOCK</code> flag on a socket. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="socket__unix_8cc_source.html#l00070">70</a> of file <a class="el" href="socket__unix_8cc_source.html">socket_unix.cc</a>.</p>

</div>
</div>
<a id="a3838219eb7d66218f5e0b1cb0e18c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3838219eb7d66218f5e0b1cb0e18c0fd">&#9670;&nbsp;</a></span>set_close_on_exec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::set_close_on_exec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxdr_1_1sock__t.html">sock_t</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the close-on-exec flag of a file descriptor. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::system_error</td><td>on failure. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="socket__unix_8cc_source.html#l00079">79</a> of file <a class="el" href="socket__unix_8cc_source.html">socket_unix.cc</a>.</p>

</div>
</div>
<a id="adc5765243b958d537f42fca8a724259f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5765243b958d537f42fca8a724259f">&#9670;&nbsp;</a></span>create_selfpipe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::create_selfpipe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structxdr_1_1sock__t.html">sock_t</a>&#160;</td>
          <td class="paramname"><em>ss</em>[2]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a socket (or pipe on unix, where both are file descriptors) that is connected to itself. </p>

<p class="definition">Definition at line <a class="el" href="socket__unix_8cc_source.html#l00089">89</a> of file <a class="el" href="socket__unix_8cc_source.html">socket_unix.cc</a>.</p>

</div>
</div>
<a id="a8e7c4c84c79a69d0bad433bff349741a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7c4c84c79a69d0bad433bff349741a">&#9670;&nbsp;</a></span>validate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::validate </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If this function template is specialized, it provides a means of placing extra restrictions on XDR data structures (beyond those of the XDR specification). </p>
<p>When a specialized <code><a class="el" href="namespacexdr.html#a8e7c4c84c79a69d0bad433bff349741a" title="If this function template is specialized, it provides a means of placing extra restrictions on XDR da...">xdr::validate</a></code> function detects a bad data argument, it should throw an exception of type <code><a class="el" href="structxdr_1_1xdr__invariant__failed.html" title="Exception for use by xdr::xdr_validate. ">xdr::xdr_invariant_failed</a></code>. Note this mechanism only works for user-defined XDR structs and unions. It does not work for enums, typedef aliases, or built-in types (int, hyper, string, vectors, etc.). </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00113">113</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a83c8a370f4f726fc09e8b491aa9c597d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c8a370f4f726fc09e8b491aa9c597d">&#9670;&nbsp;</a></span>archive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Archive , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void xdr::archive </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>By default, this function simply applies <code>ar</code> (which must be a function object) to <code>t</code>. </p>
<p>However, it does so via the <code><a class="el" href="structxdr_1_1archive__adapter.html" title="This is used to apply an archive to a field. ">xdr::archive_adapter</a></code> template class, which can be specialized to capture the field name as well. Never specialize or overload this function on <code>Archive</code> (specialize <code><a class="el" href="structxdr_1_1archive__adapter.html" title="This is used to apply an archive to a field. ">xdr::archive_adapter</a></code> instead). However, in special cases (such as <code><a class="el" href="structxdr_1_1transparent__ptr.html" title="A pointer, but that gets marshalled as the underlying object and can convert to the underlying type...">xdr::transparent_ptr</a></code>) it is reasonable to specialize this function template on <code>T</code>. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00140">140</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a74c46504e7ed6a829128f06a8d2ec591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c46504e7ed6a829128f06a8d2ec591">&#9670;&nbsp;</a></span>xdr_reinterpret()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename To , typename From &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">To xdr::xdr_reinterpret </td>
          <td>(</td>
          <td class="paramtype">From&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A reinterpret-cast like function that works between types such as floating-point and integers of the same size. </p>
<p>Used in marshaling, so that a single set of byteswap routines can be used on all numeric types including floating point. Uses a union to avoid strict pointer aliasing problems. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00215">215</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="aa2d8c028a76a0f1e55bf501fc3c1ec65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2d8c028a76a0f1e55bf501fc3c1ec65">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt;T&gt;::is_struct &amp;&amp; <a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt;T&gt;::xdr_defined, bool&gt;::type xdr::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality for XDR structures. </p>
<p>To use this operator, you will have to include using declaration <code>using <a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65" title="Equality for XDR structures. ">xdr::operator==</a></code> in the namespace of your XDR file. Note that a <code>using namespace xdr</code> using <em>directive</em> (as opposed to <em>declaration</em>) is insufficient, because the C++ standard explicitly prevents using directives from impacting argument-dependent lookup. A <code>using namespace xdr</code> directive at global scope is also insufficient, though more subtly, because standard library functions for comparing vectors will fail. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00947">947</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a9c8ca76bb3329e159c771984714a890a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8ca76bb3329e159c771984714a890a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;<a class="el" href="structxdr_1_1xdr__traits.html">xdr_traits</a>&lt;T&gt;::is_union, bool&gt;::type xdr::operator== </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality of XDR unions. </p>
<p>See note at <code><a class="el" href="namespacexdr.html#aa2d8c028a76a0f1e55bf501fc3c1ec65" title="Equality for XDR structures. ">xdr::operator==</a></code> for XDR structs. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l01017">1017</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a83e71e2866065709507c9987df76cdf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e71e2866065709507c9987df76cdf1">&#9670;&nbsp;</a></span>field_constructor</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Constexpr const <a class="el" href="structxdr_1_1field__constructor__t.html">field_constructor_t</a> xdr::field_constructor {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passed to the auto-generated _xdr_with_mem_ptr static method to construct the active union field (or at least the union field corresponding to the second argument to _xdr_with_mem_ptr, which should be the active union field). </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00855">855</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
<a id="a33ac39dce2cf36ae6fdaa09f47e7a6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33ac39dce2cf36ae6fdaa09f47e7a6a0">&#9670;&nbsp;</a></span>field_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Constexpr const <a class="el" href="structxdr_1_1field__size__t.html">field_size_t</a> xdr::field_size {}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Passed to _xdr_with_mem_ptr to compute the size of the active union field. </p>

<p class="definition">Definition at line <a class="el" href="types_8h_source.html#l00899">899</a> of file <a class="el" href="types_8h_source.html">types.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 24 2017 21:38:49 for xdrpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
