<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>xdrpp: xdrc</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">xdrpp
   </div>
   <div id="projectbrief">RFC4506 XDR compiler and message library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">xdrc </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>% xdrc(1) % David Mazieres %</p>
<h1>NAME</h1>
<p>xdrc - RFC4506 XDR compiler for libxdrpp</p>
<h1>SYNOPSIS</h1>
<p>xdrc {-hh|-serverhh|-servercc} [-o <em>outfile</em>] [-DMACRO=val...] <em>input</em>.x</p>
<h1>DESCRIPTION</h1>
<p><code>xdrc</code> compiles an RFC4506 XDR (external data representation) file into a C++11 header file, creating a new C++ type for each type defined in XDR.</p>
<h2>Native representations</h2>
<p><code>xdrc</code> uses the following representations for XDR types in C++:</p>
<ul>
<li>XDR structs are translated field-for-field into C++ structures.</li>
<li><p class="startli">XDR unions are translated into a structure in which each field is actually a method that either returns a reference to the underlying value, or throws an exception if that field is not currently selected. The discriminant method with no arguments returns the value, and with a value sets the discriminant (also constructing the appropriate union field). For example, if the XDR file contains: </p><pre class="fragment">  union MyType switch (unsigned discriminant) {
  case 0:
    int zero;
  case 1:
    string one&lt;&gt;;
  default:
    void;
  }
</pre><p class="startli">The C++ type can be accessed as follows: </p><pre class="fragment">MyType mt;
mt.discriminant(1);
mt.one() = "hello";
std::cout &lt;&lt; mt.one() &lt;&lt; std::endl;
mt.discriminant(0);
mt.zero() = 5;

std::cout &lt;&lt; mt.one() &lt;&lt; std::endl; // throws xdr_wrong_union
</pre></li>
<li>XDR <code>bool</code> is represented as a C++ <code>bool</code> (with XDR's <code>TRUE</code> translated to <code>true</code> and <code>FALSE</code> to <code>false</code>).</li>
<li>XDR [unsigned] <code>int</code> and <code>hyper</code> types are represented as the cstdint types <code>std::int32_t</code>, <code>std::uint32_t</code>, <code>std::int64_t</code>, and <code>std::uint64_t</code>. As per RFC4506, no types narrower than 32 bits exist.</li>
<li>XDR enums are translated into simple (non-class) enums with underlying type <code>std::int32_t</code>.</li>
<li>XDR pointers (<code>*</code>) are translated into C++ <code>xdr:pointer</code>, a subtype of <code>std::unique_ptr</code>. <code><a class="el" href="structxdr_1_1pointer.html" title="Optional data (represented with pointer notation in XDR source). ">xdr::pointer</a></code> adds an <code>activate()</code> method that allocates an object of the appropriate type (if the pointer is null) and returns a reference to the current object.</li>
<li>XDR fixed-length arrays are translated into C++ <code><a class="el" href="structxdr_1_1xarray.html" title="XDR arrays are implemented using std::array as a supertype. ">xdr::xarray</a></code>, a subtype of <code>std::array</code>.</li>
<li>XDR variable-length arrays (<code>type field&lt;N&gt;</code>) are translated into C++ <code><a class="el" href="structxdr_1_1xvector.html" title="A vector with a maximum size (returned by xvector::max_size()). ">xdr::xvector</a>&lt;T,N&gt;</code>, a subtype of <code>std::vector&lt;T&gt;</code>, where <code>N</code> represents the maximum size. Static constexpr method <code>max_size()</code> returns the maximum size.</li>
<li>XDR opaque is translated into C++ <code>std::uint8_t</code>, but as per RFC4506, opaque may only appear as part of a fixed- or variable-length array declaration.</li>
<li>XDR <code>string&lt;N&gt;</code> is translated into <code><a class="el" href="structxdr_1_1xstring.html" title="A string with a maximum length (returned by xstring::max_size()). ">xdr::xstring</a>&lt;N&gt;</code>, a subtype of string encoding the maximum size. Static constexpr method <code>max_size()</code> returns the maximum size.</li>
</ul>
<h2>Extensions to RFC4506</h2>
<p><code>xdrc</code> supports the following extensions to the syntax defined in RFC4506:</p>
<ul>
<li>The source file is run through the C preprocessor. Macro XDRC is pre-defined to 1, permitting the use of #ifdef to take advantage of other xdrc-specific features. Also, with the <code>-hh</code> option, <code>XDRC_HH=1</code> is pre-defined, and with the <code>-serverhh</code> and <code>-servercc</code> options, <code>XDRC_SERVER=1</code> is predefined.</li>
<li>Lines beginning with a <code>%</code> sign are copied verbatim into the output file.</li>
<li>Portions of the input file may be bracketed by <code>namespace myns {</code> ... <code>}</code>. The corresponding C++ will be embedded in the same namespace.</li>
<li>Type names may include a namespace scope <code>::</code>, so as to be able to make use of types defined in a different namespace. (Alternatively, a literal can be used, such as <code>using namespace otherns;</code>.)</li>
</ul>
<p>The namespace-related extensions should be used sparingly if compatibility with other languages and XDR compilers is desirable. While it may be useful to enclose an entire source file in a <code>namespace</code> for consistency, it is a good idea to wrap such directives inside <code>#if XDRC</code> / <code>#endif</code> conditionals. Heavy use of namespaces for internal structuring purposes (e.g., wrapping every <code>enum</code> in its own namespace) is a bad idea as it will make protocols incompatible with RFC4506.</p>
<h2>Serialization and traversing data structures</h2>
<p>A template class <code><a class="el" href="structxdr_1_1xdr__traits.html" title="Metadata for all marshalable XDR types. ">xdr::xdr_traits</a>&lt;T&gt;</code> is used to hold metadata for each native C++ type <code>T</code> representing an XDR type. For XDR structs, unions, arrays and pointers, this traits class contains two important static methods: </p><pre class="fragment">template&lt;class Archive&gt; void save(Archive &amp;archive, const T &amp;);
template&lt;class Archive&gt; void load(Archive &amp;archive, T &amp;);
</pre><p>These methods use <code>archive</code> as a function object and call it on every field in the data structure. Hence, the type <code>Archive</code> can have an overloaded <code>operator()</code> that does different things for different types. To implement an archive, you will need to support the following types:</p>
<blockquote class="doxtable">
<ul>
<li><code>bool</code>, <code>std::int32_t</code>, <code>std::uint32_t</code>, <code>std::int64_t</code>, <code>std::uint64_t</code>, <code>float</code>, <code>double</code>, <code><a class="el" href="structxdr_1_1xstring.html" title="A string with a maximum length (returned by xstring::max_size()). ">xdr::xstring</a></code>, <code><a class="el" href="structxdr_1_1opaque__array.html" title="XDR opaque is represented as std::uint8_t;. ">xdr::opaque_array</a></code> and <code><a class="el" href="namespacexdr.html#aa08a12c21ae987530a9aadfdec31e593" title="Variable-length opaque data is just a vector of std::uint8_t. ">xdr::opaque_vec</a></code> (the latter two are not considered containers, despite being implemented in terms of <code>xarray</code> and <code>xvector</code>). </li>
</ul>
</blockquote>
<blockquote class="doxtable">
<ul>
<li>The <code><a class="el" href="structxdr_1_1xarray.html" title="XDR arrays are implemented using std::array as a supertype. ">xdr::xarray</a></code>, <code>xdr:xvector</code>, and <code><a class="el" href="structxdr_1_1pointer.html" title="Optional data (represented with pointer notation in XDR source). ">xdr::pointer</a></code> containers of the above types (or their supertypes <code>std::array</code>, <code>std::vector</code>, and <code>std::unique_ptr</code>). </li>
</ul>
</blockquote>
<blockquote class="doxtable">
<ul>
<li>Any field types that are themselves XDR structures. </li>
</ul>
</blockquote>
<p>For debugging purposes and formats (such as JSON) that need access to field names, it is also possible for the <code>Archive</code> type to receive the field names of fields that are traversed. The following template (in the <code>xdr::</code> namespace) can be specialized to prepare arguments by bundling them with their names: </p><pre class="fragment">template&lt;typename Archive&gt; struct archive_adapter {
  template&lt;typename T&gt; static void
  apply(Archive &amp;ar, T &amp;&amp;t, const char *) {
    ar(std::forward&lt;T&gt;(t));
  }
};
</pre><h2>Program and version representations</h2>
<p>For each <code>version</code> block (declared inside a <code>program</code> block, as documented in Section 12.2 of RFC5531), <code>xdrc</code> generates a C++ struct of the same name. As a consequence, versions should use unique names. The version struct generated by <code>xdrc</code> contains no data fields, but rather is used to encode information about all procedures in the interface for use by templates. Specifically, the version struct contains the following fields:</p>
<ul>
<li><code>program</code> - A <code>uint32_t</code> encoding the program number specified in the XDR input file.</li>
<li><code>version</code> - A <code>uint32_t</code> encoding the program number specified in the XDR input file.</li>
<li><code>static constexpr const char *program_name()</code> - A static method returning the textual name of the program.</li>
<li><code>static constexpr const char *version_name()</code> - A static method returning the textual name of the version.</li>
<li>For each procedure <code>myproc</code>, an inner struct <code>myproc_t</code> encoding the following metadata about the procedure:<ul>
<li><code>interface_type</code> - a typedef of the version struct containing this proc struct.</li>
<li><code>proc</code> - a <code>uint32_t</code> containing the procedure number.</li>
<li><code>proc_name()</code> - a static constexpr function returning the name of the procedure.</li>
<li><code>arg_type</code> - exists only if the procedure takes 0 or 1 argument. If it takes 0 arguments, then a typedef of void. If it takes one argument, then a typedef of the argument type.</li>
<li><p class="startli"><code>arg_tuple_type</code> - a <code>std::tuple</code> parameterized by the types of the argument list of this procedure. E.g., for a declaration </p><pre class="fragment">  void myproc(void) = 1;
</pre><p class="startli"><code>arg_tuple_type</code> is <code>std::tuple&lt;&gt;</code>. For a declaration </p><pre class="fragment">void myproc(int, bool) = 1;
</pre><p class="startli"><code>arg_tuple_type</code> is <code>std::tuple&lt;std::int32_t, bool&gt;</code>.</p>
</li>
<li><code>res_type</code> - the type returned by the procedure, including <code>void</code> for procedures declared to return void.</li>
<li><code>res_wire_type</code> - the type returned by the procedure, except for procedures returning <code>void</code>, for which <code>res_wire_type</code> is typedefed to <code>xdr_void</code> (a.k.a., <code>std::tuple&lt;&gt;</code>), an empty data structure whose wire representation is 0 bytes.</li>
<li><code>dispatch(c, a1, a2, ...)</code> - a static method that calls <code>c.myproc(a1, a2, ...)</code> (where <code>myproc</code> is the name of this procedure) and returns the result. Hence, given a procedure metadata structure <code>P</code>, a template can use <code>P::dispatch</code> to call a method called <code>myproc</code> on an arbitrary class without needing to know that the name of the procedure is <code>myproc</code>.</li>
</ul>
</li>
<li><p class="startli"><code>call_dispatch(t, procno, a1, a2, ...)</code> - calls the template method <code>dispatch</code> on object <code>t</code>, passing as a template type argument the procedure metadata type corresponding to procedure number <code>procno</code> (a <code>std::uint32_t</code>). Returns true if <code>procno</code> was valid for this program/version. <code>call_dispatch</code> is perhaps best illustrated by example. Given the source: </p><pre class="fragment">  program myprog {
    version myprog1 {
       void null(void) = 0;
       void non_null(int) = 1;
    } = 1;
  } = 0x40000000;
</pre><p class="startli">You will get: </p><pre class="fragment">  struct myprog1 {
    // ...
    struct null_t { /* ... */ };
    struct non_null_t { /* ... */ };

    template&lt;typename T, typename...A&gt; static bool
    call_dispatch(T &amp;&amp;t, std::uint32_t proc, A &amp;&amp;...a) {
      switch(proc) {
      case 0:
        t.template dispatch&lt;null_t&gt;(std::forward&lt;A&gt;(a)...);
        return true;
      case 1:
        t.template dispatch&lt;non_null_t&gt;(std::forward&lt;A&gt;(a)...);
        return true;
      }
      return false;
    }
  };
</pre></li>
<li><code>_xdr_client</code> - a template struct, <code>template&lt;typename T&gt; struct _xdr_client</code>, containing a <code>T</code> (a pointer-like type), and whose constructor arguments are passed to <code>T</code>. In addition, this structure contains one method for each procedure, that calls template method <code>invoke</code> on the object pointed to by <code>T</code> with the following template typename arguments: The first argument is the procedure metadata type for this procedure. The remaining (variadic) arguments are the types of all the arguments passed to this procedure. Continuing the example above, <code>myprog1</code> would contain the following structure: <pre class="fragment">  template&lt;typename T&gt; struct _xdr_client {
    T t_;
    template&lt;typename...ARGS&gt; _xdr_client(ARGS &amp;&amp;...args)
      : t_(std::forward&lt;ARGS&gt;(args)...) {}

    template&lt;typename...ARGS&gt; auto
    null(ARGS &amp;&amp;...args) -&gt;
    decltype(t_-&gt;template invoke&lt;null_t&gt;(
             std::forward&lt;ARGS&gt;(args)...)) {
      return t_-&gt;template invoke&lt;null_t&gt;(
             std::forward&lt;ARGS&gt;(args)...);
    }

    template&lt;typename...ARGS&gt; auto
    non_null(ARGS &amp;&amp;...args) -&gt;
    decltype(t_-&gt;template invoke&lt;non_null_t, int&gt;(
             std::forward&lt;ARGS&gt;(args)...)) {
      return t_-&gt;template invoke&lt;non_null_t, int&gt;(
             std::forward&lt;ARGS&gt;(args)...);
    }
  };
</pre></li>
</ul>
<h1>OPTIONS</h1>
<p>-hh : Selects C++ header file output. This is the main output format, and its output is required for use with libxdrpp.</p>
<p>-serverhh : Generates a C++ header file containing declarations of objects you can use to implement a server for each interface, using <code>srpc_tcp_listener</code> or <code>arpc_tcp_listener</code>. See the EXAMPLES section.</p>
<p>-servercc : Generates a .cc file containing empty method definitions corresponding to the object files created with <code>-serverhh</code>.</p>
<p>-a, -async : With <code>-serverhh</code> or <code>-servercc</code>, says to generate scaffolding for an event-driven interface to be used with <code>arpc_tcp_listener</code>, as opposed to the default <code>srpc_tcp_listener</code>.</p>
<p>-p, -ptr : With <code>-serverhh</code> or <code>-servercc</code>, says to generate methods that take arguments and return values as <code>unique_ptr&lt;T&gt;</code>. The default is to pass arguments by C++ reference. Note that the library works with both references and <code>unique_ptr</code> arguments, so this argument only says what one would like to start out with, and one can later edit individual prototypes to change pointers to references.</p>
<p>-o <em>outfile</em> : Specifies the output file into which to write the generated code. The default, for <code>-hh</code>, is to replace <code>.x</code> with <code>.hh</code> at the end of the input file name. <code>-serverhh</code> and <code>-servercc</code> append <code>.server.hh</code> and <code>.<a class="el" href="server_8cc_source.html">server.cc</a></code>, respectively. The special <em>outfile</em> <code>-</code> sends output to standard output.</p>
<p>-DMACRO=val : The input file is run through the C preprocessor, and this option adds additional defines. (Note that the symbol <code>XDRC</code> is always defined to 1, if you wish to test for xdrc vs. other RPC compilers.)</p>
<h1>EXAMPLES</h1>
<p>Consider the following XDR program definition in a file myprog.x: </p><pre class="fragment">typedef string big_string&lt;&gt;;

program MyProg {
  version MyProg1 {
    void null(void) = 0;
    big_string hello(int) = 1;
    big_string goodbye(big_string) = 2;
  } = 1;
} = 0x2dee1645;
</pre><p>The <code>-serverhh</code> option will generate a header with the following class: </p><pre class="fragment">class MyProg1_server {
public:
  using rpc_interface_type = MyProg1;

  void null();

  unique_ptr&lt;big_string&gt;
  hello(unique_ptr&lt;int&gt; arg);

  unique_ptr&lt;big_string&gt;
  goodbye(unique_ptr&lt;big_string&gt; arg);
};
</pre><p>You have to add any fields you need to this structure, then implement the three methods corresponding to the interface. (Note the very important type <code>rpc_interface_type</code> tells the library which interface this object implements.) Given such an object, you can then implement a TCP RPC server (that registers its TCP port with rpcbind) as follows: </p><pre class="fragment">#include &lt;xdrpp/server.h&gt;
#include "xdrpp/myprog.server.h"

using namespace xdr;

int
main(int argc, char **argv)
{
  MyProg1_server s;
  srpc_tcp_listener rl;
  rl.register_service(s);
  rl.run();
  return 1;
}
</pre><p>To implement a simple client that talks to this server, you can use code like the following: </p><pre class="fragment">#include &lt;iostream&gt;
#include &lt;xdrpp/srpc.h&gt;
#include "myprog.h"

using namespace std;
using namespace xdr;

int
main(int argc, char **argv)
{
  unique_fd fd = tcp_connect_rpc(argc &gt; 2 ? argv[2] : nullptr,
                                 MyProg1::program,
                                 MyProg1::version);
  srpc_client&lt;MyProg1&gt; c{fd.get()};
  unique_ptr&lt;big_string&gt; result = c.hello(5);
  cout &lt;&lt; "The result of hello(5) is " &lt;&lt; *result &lt;&lt; endl;
  return 0;
}
</pre><h2>Compilation</h2>
<p>The generated <code>xdrc</code> output files must be compiled with a compiler supporting C++11 (or later, such as C++14) and expect to be used with libxdrpp. This typically requires extra compiler flags (e.g., <code>-std=c++11</code>). You can use pkgconfig to find the location of the headers and libraries. With CXX set to both g++ and clang++, the following Makefile variables work: </p><pre class="fragment">CXXFLAGS = -std=c++11 `pkg-config --cflags xdrpp`
LIBS = `pkg-config --libs xdrpp`
</pre><h1>FILES</h1>
<p>PREFIX/include/xdrc/types.h : Types used in generated C++ code.</p>
<p>PREFIX/include/xdrc/cereal.h : Integration with the <a href="http://uscilab.github.io/cereal/">cereal</a> serialization library.</p>
<h1>SEE ALSO</h1>
<p><a href="http://tools.ietf.org/html/rfc4506">http://tools.ietf.org/html/rfc4506</a></p>
<p><a href="http://tools.ietf.org/html/rfc5531">http://tools.ietf.org/html/rfc5531</a></p>
<h1>BUGS</h1>
<p>Certain names that are legal in XDR cannot be used as type or field names. For example, C++ keywords are not allowed (<code>namespace</code>, <code>template</code>, etc.). In addition, <code>xdrc</code> uses a number of names beginning with underscores (especially names beginning with prefix <code>_xdr_</code>). Hence you should avoid starting your field names with underscore. Union types use private fields that have the names of the XDR fields with underscore appended. Hence, in a union you cannot use two field names one of which is the other with an underscore appended.</p>
<p><code>xdrc</code> translates an XDR <code>quadruple</code> to C++ type called <code>quadruple</code>, but most compilers do not have such a type. Moreover, libxdrpp does nothing to support such a type.</p>
<p>IEEE 754 floating point allows for many different NaN (not a number) values. During serialization, xdrpp simply passes the bytes of a floating point value through as-is (byteswapping on little-endian machines). Different C++ compilers and libraries could conceivably produce different NaN values from the same code. Hence, in the presence of floating point, the serialization output of seemingly deterministic code may depend on the compiler. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 24 2017 21:38:49 for xdrpp by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
